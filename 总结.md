Vue 是一个提供了 MVVM 风格的双向数据绑定的框架。它的核心是 MVVM 中的 VM，也就是 ViewModel。 ViewModel负责连接 View 和 Model，保证视图和数据的一致性。

在 Vue 中，Model 和 VM，VM 和 和 View 之间都是双向数据绑定，实现方式是数据劫持。

react，单向数据流。本身只是 一个函数 ui = render (data) 官方就这么简单一个公式。加上状态管理等，可以做 MVVM 风格的开发。


1:==========promise.all
promise.prototype.all=function(promises){
        let aResult = [];    //用于存放每次执行后返回结果
    return new Promise(function(resolve,reject){
        let i=0;
        next();
        function next(){
            promises[i].then(
            function(res){   
            aResult.push(res);
            i++;
            if(i===promises.length){
            resolve(aResult);
            }else{
                next();
            }
            };
            function(err) {
                 return reject(err);
             });
            )
        }

    })
}
React 是一个用于构建用户界面的 JAVASCRIPT 库。
React 主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。
redux是单向数据流，通过action触发reducer来修改store，redux存在中间件，中间件改写了dispatch方法。

什么是virtual dom？
用js模拟真实dom:
作用
DOM的对比，放在js层来做。
提高重绘性能。
diff算法
找出必须要更新的DOM的办法 = diff算法
核心api
patch(container, Vnode)
patch(Vnode, newVnode)
具体实现思路：
patch(container, Vnode):
作用将虚拟dom转化成真是dom，并挂载到container上。
patch(Vnode, newVnode)：
比较两个Vnode节点：
作用
DOM的对比，放在js层来做。

提高重绘性能。
https://zhuanlan.zhihu.com/p/82652544

构建一个虚拟DOM并转换为真实DOM
关于真实DOM与虚拟DOM
1.在学习虚拟DOM之前，让我们先来了解一下真实的DOM结构，这里不得不提的是关于浏览器渲染方面的知识。
      当浏览器拿到一个HTML文件，首先会根据HTML文件构建出一个DOM树来，并行加载CSS文件，图片，JS脚
 本，值得注意的是DOM树的渲染和CSSOM渲染是并行执行的，而不是串行进行的。
    （JS脚本需要在html尾部加载，或是写入window.onload方法里，让DOM加载完成后再去加载JS脚本，防止
 进程阻塞，JS脚本是同步加载的）。
 	 在构建完DOM树和CSSOM树之后，即可开始Render Tree即渲染树的构建，进行布局，绘制。
2.为什么要使用虚拟DOM？
	当我们对DOM树有大量操作时，每一次操作都会进行重新渲染。虚拟DOM是构建一个虚拟的DOM树，将多个
改变反应到虚拟DOM树中去，等页面更新完成后，打包对真实DOM进行操作。这样子就可以降低回流或重绘的次数
提高性能。
3.构建一个虚拟DOM
一个ELement对象相当于虚拟DOM上一个节点，参数如下：
tagName：元素名称
props : 元素属性，例如：class title等（以键值对方式存在）
children : 该节点下的子节点数组
现在我们来定义一个虚拟DOM树
4.将虚拟DOM映射为真实DOM
为Element对象添加原型方法，render函数。函数作用：将虚拟DOM树映射为真实DOM。这里使用了深度优先DFS
算法进行节点的遍历。
5.最后一步，将创建的真实DOM添加入文档流中。
6.显示效果
总结：虚拟DOM在框架如VUE，React中的运用，保证了性能下限，虚拟DOM是JS对象的抽象化，具有更好的跨平台性，无需手动对DOM进行操作。对于框架而言，是提供一个普适化的解决方案。使用虚拟DOM在保证代码的可维护性下，提供一个不错的性能。
对于一些对性能要求极高的平台，如VScode，采用手动优化DOM的操作进行极端的性能优化
原文链接：https://blog.csdn.net/qq_38918017/article/details/108321192


问题2:==========react diff算法以及原理
什么是diff算法
react 作为一款最主流的前端框架之一，在设计的时候除了简化操作之外，最注重的地方就是节省性能了。diff算法就是为节省性能而设计的，diff算法和虚拟DOM的完美结合是react最有魅力的地方。
diff算法的基本流程：
第一次render在执行的时候会将第一次的虚拟dom做一次缓存，第二次渲染的时候会将新的虚拟dom和老的虚拟dom进行对比。这个对比的过程其实就是diff算法。
diff算法的作用
在DOM需要更新的时候，通过diff算法可以 计算出 虚拟DOM 中真正变化的部分，从而只针对变化的部分进行更新渲染，避免”牵一发而动全身“，造成性能浪费。
普通的diff算法
虽然完美地实现了找不同的功能，但是傻瓜式的循环递归对节点进行依次的对比，使其算法的时间复杂度为O(n^3)，其中n是dom树的节点数。如果dom数足够大的话，这个算法将对cpu形成绝杀。
React中的diff算法
为了优化diff算法，react中对普通的diff算法实行了三大策略，成功将时间复杂度降为O(n)

策略一：tree diff —— 层级对比
由于开发过程中极少出现DOM的跨层级移动，所以tree diff 忽略了DOM节点的跨层级移动。（react不建议开发人员跨层级移动DOM）
策略二：component diff —— 组件对比
同类型的两个组件，直接比较Virtual DOM树，不同类型的组件将会被判定作为脏组件(dirty component)处理，直接删除或创建新组件
策略三：element diff —— 节点对比
对于同一层级的一组子节点，通过分配唯一唯一key值进行区分


tree diff
tree diff 是diff算法的基础策略，它的重点在于同层比较。
出于对diff算法的优化，react的tree diff对DOM节点的跨层级移动的操作忽略不计，react对Virtual DOM树进行层级控制，也就是说只对相同层级的DOM节点进行比较（即同一个父节点下的所有子节点）。对比时，一旦发现节点不存在，则直接删除掉该节点以及之下的所有子节点。这样秩序对DOM树进行依次遍历，就可以完成整个树的对比。时间复杂度为O(n)
一个疑问：既然tree diff忽略了跨层级移动的操作，如果这种情况出现了，diff算法会怎么处理呢？
答：不管，多了就新增，少了就删除（只有创建节点和删除节点的操作）。所以官方明确建议不要进行DOM节点的跨层级操作。

component diff
component diff是组件间的对比

在遇到组件之间的比较时，有三种策略

对比时，遇到同一类型的组件遵循 tree diff，进行层级对比
对比时，一旦遇到不同类型的组件，直接将这个不同的组件判断为 dirty component（脏组件），并替换该组件和之下所有的子节点。
对比时，在同一类型的两个组件中，如果你知道这个组件的 Virtual DOM没有任何变化，你（开发者）就可以手动使用 shouldComponentUpdate() 来判断组件是否需要进行diff，进一步的提升了diff效率和性能
优化点：

避免使用结构相同但是类型不同的组件，因为虽然组件的结构不需要改动，但是由于类型不同的原因，diff会直接销毁该组件并重建，虽然这种情况极少出现，但是造成的性能浪费挺严重的。
对于同一类型并且没有变化的组件，合理使用 shouldComponentUpdate() 进行优化

element diff
element diff 是针对同一层级的element节点的

在双方同一层级的节点对比时，有三种情况

面对全新的节点时，执行插入操作 —— INSERT_MARKUP

这点不需要过多解释

面对多余的节点时，执行删除操作 —— REMOVE_NODE

删除操作有两种情况：

组件新集合中有组件旧集合中的类型，但对应的element不可更新，只能执行删除
旧组件不在新集合里面，执行删除
面对换位的节点时，执行移动操作 —— MOVE_EXISTING

比如该层级的组件原本是 [A,B,C,D] ，新的结构为 [A,D,B,C] ，只进行了移动操作。在传统的diff算法中，只要遇见不同（B/D）就删除并重新插入，这样的做法过于粗暴，浪费了很多可以复用的节点，所以在element diff中，对新旧该层级的对比双方都添加了唯一的key值进行区分，只要对应的key值对应的元素没有改变，则只需要执行移动即可。

细节：

新旧节点会遍历后对比下标，新的下标称为lastIndex，旧的称为index，如果lastIndex大于index，需要将节点旧的节点移动到新的位置，相反则不动。
如果没有找到对应位置节点，则执行新增； 如果旧的节点在新的节点组用不到，则执行删除；一般是在最后做删除操作。
特殊情形，最后一个节点移动到第一个位置，会导致，前面的n-1个节点都进行后移，影响性能。尽量避免这样的操作。


diff算法中，子节点更新的完整流程
子节点更新时，会出现以下几种情况：

当旧的子节点是单个的子节点的时候
如果新的子节点也是单个的，则对比子节点的内容，如果不一样则更新内容
如果新的子节点是空的则删除旧的子节点
如果新的子节点是多个的，则需要遍历挂载（创建插入）
当旧的子节点是空节点的时候
如果新的子节点是单个的，则进行插入操作
如果新的子节点是多个的，则遍历插入
如果新的子节点是空的，不用管
当旧的子节点是多个的时候
如果新的子节点是单个的，则需要遍历删除旧的子节点然后插入新的子节点
如果新的子节点是空的，则需要遍历删除旧的子节点
如果新的子节点也是多个的：
通过遍历判断有没有拥有相同key值的子节点，如果有的话则更新它的属性和内容
通过遍历判断新的子节点的位置和旧的子节点的位置是否一致（下标是否一致） ，如果一致则更新内容和属性，如果不一致则将旧的子节点在新的子节点的位置进行插入
旧的子节点中拥有的虚拟dom，新的子节点中没有，则需要对比删除

原文链接：https://blog.csdn.net/qq_42941302/article/details/107151189

问题3:==========fiber 树
背景介绍
react fiber架构有两个主要的阶段：reconciliation/render 和 commit。在render阶段，react遍历整个组件树执行了以下操作：

更新state和props
调用生命周期钩子函数
遍历组件的子元素，与之前的子元素进行比较，得到需要进行的DOM更新

如果react同步的遍历整个组件树，执行上述操作，可能会执行超过16ms（如果屏幕帧率60HZ），阻塞UI渲染，造成动画掉帧，出现视觉上的卡顿等。

浏览器幕后任务协作调度 API requestIdeleCallback在浏览器的空闲时段内调用的函数排队，使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。

如果我们使用一个performWork函数来执行React对组件树的整个操作，并使用requestIdleCallback API来对该任务进行调度，那么我们的代码逻辑可能是这样子：我们对一个组件进行处理并返回下一个组件等待调度，这样我们就不用像React16前的版本那样，同步的遍历整个组件树。


但是我们需要一种将render中的组件树的遍历过程分解为一个个增量单元的方法，即可以在完成某个组件的reconciliation之后，将调度权交还给浏览器以执行高优先级的用户交互、UI渲染等操作，待浏览器空闲时再继续下一个组件的reconciliation。 如果继续使用之前的组件树形结构，如下图所示，我们只能用递归的方式去实现组件树的遍历。
// 深度优先遍历组件树
const root = document.getElementById('root');
function logName(node){
  console.log(node.dataset.name)
}
function traversalTree(root){
  logName(root);
  const childNodes = root.childNodes;
  for(let childNode of childNodes){
    if(childNode.nodeType !== 3){
      traversalTree(childNode);
    } 
  }
}
traversalTree(root);

//输出
a1, b1, b2, c1, d1, d2, b3, c2
递归方法非常适用于遍历树形结构，如上所示，但是递归模型无法做到增量渲染，也不能实现暂停某个组件的渲染并在浏览器空闲的时候继续执行。所以React采用了基于链表的Fiber模型

2. Fiber链表遍历过程
Fiber链表结构遍历需要以下三个字段：

child——指向第一个子节点
sibiling——指向第一个兄弟节点
return——指向父节点
function workLoop(){
  while(nextUnitOfWork  && !shouldYield()){
    nextUnitOfWork = performUnitWork(nextUnitOfWork)
  }
}
const root = rootFiber;
function performUnitWork(node){
  //  这里对该节点执行render流程
    let child = perWorkOfNode(node)
    // 如果有子节点，继续遍历子节点
    if(child){
      return child;
    }
          // 如果回到了根节点，表示Fiber链表遍历完成
    if(node === root){
      return null
    }

    //如果没有子节点，也没有兄弟节点，则回父节点，如果父节点依然没有兄弟节点，则回到更上一层节点
    while(!node.sibling){
      if(!node.return || node.return === root){
        return nill
      }
      node = node.return;
    }
   
    return node.sibling;
}
上述算法使用nextUnitOfWork变量保存对当前Fiber节点的引用，能够异步的遍历组件树对应的每个Fiber节点，用requestIdleCallback包裹workLoop，使用shouldYield来检查是否有剩余时间执行nextUnitOfWork，如果没有剩余时间，则将控制权交还给浏览器，等待下一次调度从中断的nextUnitOfWork继续执行。


Fiber Reconciler 的优势
通过分析上述两种数据结构实现的代码，可以得出下面结论:

基于树的深度遍历实现的 Reconciler: 一旦进入调用栈便无法暂停;
基于链表实现的 Reconciler: 在 while(true) {} 的循环中, 可以通过 currentNode 的赋值重新得到需要操作的节点，而在赋值之前便可以'暂停'来执行其它逻辑, 这也是 requestIdleCallback 能得以在 Fiber Reconciler 的原因。


var a1 = { name: 'a1', render = () => [b1, b2, b3] }
var b1 = { name: 'b1', render = () => [c1] }
var b2 = { name: 'b2', render = () => [c2] }
var b3 = { name: 'b3', render = () => [] }
var c1 = { name: 'c1', render = () => [d1] }
var c2 = { name: 'c2', render = () => [] }
var d1 = { name: 'd1', render = () => [d2] }
var d2 = { name: 'd2', render = () => [] }

首先, 构建节点的数据结构, 如下所示:

var FiberNode = function(instance) {
  this.instance = instance
  this.parent = null
  this.sibling = null
  this.child = null
}
然后创建一个将节点串联起来的 connect 函数:

var connect = function(parent, childList) {
  parent.child = childList.reduceRight((prev, current) => {
    const fiberNode = new FiberNode(current)
    fiberNode.parent = parent
    fiberNode.sibling = prev
    return fiberNode
  }, null)
 
  return parent.child
}
在 JavaScript 中实现链表的数据结构可以巧用 reduceRight

connect 函数中实现了上述链表关系。可以像这样使用它:

var parent = new FiberNode(a1)
var childFirst = connect(parent, a1.render())
这样子便完成了 a1 节点指向 b1 节点的链表、b1、b2、b3 节点间的单向链表以及 b1、b2、b3 节点指向 a1 节点的链表。

最后剩下 goWalk 函数将全部节点给遍历完。

// 打印日志以及添加列表
var walk = function(node) {
  console.log(node.instance.name)
  const childLists = node.instance.render()
  let child = null
  if (childLists.length > 0) {
    child = connect(node, childLists)
  }
  return child
}
 
var goWalk = function(root) {
  let currentNode = root
 
  while (true) {
    const child = walk(currentNode)
    // 如果有子节点
    if (child) {
      currentNode = child
      continue
    }
 
    // 如果没有相邻节点, 则返回到父节点
    while (!currentNode.sibling) {
      currentNode = currentNode.parent
      if (currentNode === root) {
        return
      }
    }
 
    // 相邻节点
    currentNode = currentNode.sibling
  }
}
 
// 调用
goWalk(new FiberNode(a1))

打印结果为 a1 b1 c1 d1 d2 b2 c2 b3

破解JavaScript中同步操作时间过长的方法其实很简单——分片。

把一个耗时长的任务分成很多小片，每一个小片的运行时间很短，虽然总时间依然很长，但是在每个小片执行完之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的机会。

React Fiber把更新过程碎片化，执行过程如下面的图所示，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。

维护每一个分片的数据结构，就是Fiber。
为了达到这种效果，就需要有一个调度器 (Scheduler) 来进行任务分配。任务的优先级有六种：

synchronous，与之前的Stack Reconciler操作一样，同步执行
task，在next tick之前执行
animation，下一帧之前执行
high，在不久的将来立即执行
low，稍微延迟执行也没关系
offscreen，下一次render时或scroll时才执行

参考文档
https://segmentfault.com/a/1190000022172451
https://blog.csdn.net/weixin_30588729/article/details/95340552
https://blog.csdn.net/leelxp/article/details/107607391
https://blog.csdn.net/sinat_17775997/article/details/94430227


问题4======HTML渲染机制
用户输入url地址，浏览器根据域名寻找IP地址
浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求
服务器端接受请求，处理请求生成html代码，返回给浏览器，这时的html页面代码可能是经过压缩的
浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染
　　解析渲染该过程主要分为以下步骤：

解析HTML
构建DOM树
DOM树与CSS样式进行附着构造呈现树
布局
绘制

问题五==========React Hooks 
https://blog.csdn.net/setSail20181101/article/details/105722851
函数式组件更灵活
1.组件之前状态共享实现逻辑复杂
2.class的this指向问题
3.难以记忆的生命周期
4.复杂组件难以理解，高阶组件和函数组件嵌套过深
hooks的原理
- 单向链表通过next把hooks串联起来
- memoizedState存在fiber node上，组件之间不会相互影响
- useState和useReducer中通过dispatch/Action调度更新任务

Hooks的使用注意事项
只能在顶层调用Hooks? Hooks是使用数组或单链表串联起来，Hooks顺序修改会打乱执行结果
useState在多个组件中引入，彼此之间会不会有影响? 在React中Hooks把数据存在fiber node上的，每个组件都有自己的currentlyRenderingFiber.memoizedState
Hooks的问题
只能在顶层调用Hooks? Hooks是使用数组或单链表串联起来，Hooks顺序修改会打乱执行结果
useState在多个组件中引入，彼此之间会不会有影响? 在React中Hooks把数据存在fiber node上的，每个组件都有自己的currentlyRenderingFiber.memoizedState

use开头，有顺序的
Hook　轻松添加　State
function useState(initialValue) {
  var state = initialValue;
  function setState(newState) {
    state = newState;
    render();
  }
  return [state, setState];

1.useState是一个hook。 它的名字以“use”开头（这是Hooks的规则之一 - 它们的名字必须以“use”开头）。
2.useState hook 的参数是 state 的初始值，返回一个包含两个元素的数组:当前state和一个用于更改state 的函数。
3.类组件有一个大的state对象，一个函数this.setState一次改变整个state对象。
useEffect 用来处理副作用
为什么第二个参数是空数组，相当于 componentDidMount 
function useEffect(callback, depArray) {
  const hasNoDeps = !depArray; // 如果 dependencies 不存在
  const hasChangedDeps = _deps
    ? !depArray.every((el, i) => el === _deps[i]) // 两次的 dependencies 是否完全相等
    : true;
  /* 如果 dependencies 不存在，或者 dependencies 有变化*/
  if (hasNoDeps || hasChangedDeps) {
    callback();
    _deps = depArray;
  }
 useEffect(() => {
        document.title = 'Hello, ' + name;
    }, [name]); // Our deps
上面这段代码相当于告诉react，我这个effect的依赖项是name这个变量，只有当name发生变化的时候才去执行里面的函数

而且这个比较是浅比较，如果state是一个对象，那么对象只要指向不发生变化，那么就不会执行effect里面的函数
1. 有两个参数 callback 和 dependencies 数组
2. 如果 dependencies 不存在，那么 callback 每次 render 都会执行
3. 如果 dependencies 存在，只有当它发生了变化， callback 才会执行


useContext
使用方法：

    const value = useContext(myContext);
当最近的一个myContext.Provider更新的时候，这个hook就会导致当前组件发生更新
useReducer:
    function reducer(state, action) {
        switch (action.type) {
            case 'increment':
                return {count: state.count + 1};
            case 'decrement':
                return {count: state.count - 1};
            default:
                throw new Error();
        }
    }

    function Counter() {
        const [state, dispatch] = useReducer(reducer, {count: 100});

        // 如果此处不传入一个initialState: {count: 100}的话，那么默认initialState就是undefined，那么后面的取值就会报错
        return (
            <>
                Count: {state.count}
                <button onClick={() => dispatch({type: 'increment'})}>+</button>
                <button onClick={() => dispatch({type: 'decrement'})}>-</button>
            </>
        );
    }
useCallback:
    const memoizedCallback = useCallback(
        () => {
            doSomething(a, b);
        },
        [a, b],
    );
    // 返回的memoizedCallback只有当a、b发生变化时才会变化，可以把这样一个memoizedCallback作为depen
useMemo
    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
useRef
    const refContainer = useRef(initialValue);
注意：useRef返回相当于一个{current: ...}的plain object，但是和正常这样每轮render之后直接显式创建的区别在于，每轮render之后的useRef返回的plain object都是同一个，只是里面的current发生变化

而且，当里面的current发生变化的时候并不会引起render
https://blog.csdn.net/setSail20181101/article/details/105722851

问题六==========hash、chunkhash使用场景
chunkhash是根据具体模块文件的内容计算所得的hash值，所以某个文件的改动只会影响它本身的hash指纹，不会影响其他文件。
hash可以作为版本控制的一环，将其作为编译输出文件夹的名称统一管理，

https://www.cnblogs.com/ihardcoder/p/5623411.html


问题七========useLayoutEffect，useMemo性能优化
https://blog.csdn.net/qq_28483283/article/details/115763503


问题八===========http2和多路复用
HTTP/2与雪碧图性能对比
HTTP/1.x的缺陷
连接无法复用，需要开启多个连接
没有进行头部压缩，协议开销大
线头阻塞
HTTP/2 协议中的一些主要新特性
1. 性能提升的核心——二进制帧层性能提升的核心在于二进制帧层.它指HTTP消息在客户端和服务端如何封装和传输.采用二进制格式传输数据而非HTTP/1.x的文本传输，二进制格式在解析和优化扩展上具有更多的优势。
2. 多路复用
在HTTP/1.1中，如果客户端为了提高性能想要在一个TCP连接内同时发起多个请求，每个请求必须按顺序被服务器依次响应，如果某一个请求特别耗时，那么后面的请求将会被一直阻塞。而在HTTP/2中，如果在一个TCP连接内同时发起多个请求，每个消息可以被拆成互不依赖的帧并且各帧之间交错发送，然后在另一端重新把帧组装起来。这个特性就叫做多路复用。
3.头部压缩-HPACKHTTP 
1.1请求的大小变得越来越大，有时甚至会大于TCP窗口的初始大小，因为它们需要等待带着ACK的响应回来以后才能继续被发送。HTTP/2对消息头采用HPACK（专为http2头部设计的压缩格式）进行压缩传输，能够节省消息头占用的网络的流量。而HTTP/1.x每次请求，都会携带大量冗余头信息，浪费了很多带宽资源
4.Server Push
服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML再发送这些请求。服务端可以主动推送，客户端也有权利选择接收与否。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。
雪碧图1.原理CSS Sprites 因其英文被称为雪碧图。

主要用于把一堆小图标整合在一张背景透明的大图上，通过设置对应的位置来显示不同的图片，目的是大幅减轻服务器对图片的请求数量，是前端性能优化的一种方式。2.优缺点：
优点：减少网页的HTTP请求，提高页面性能， 减少图片命名的困扰
缺点：需要计算每个图片的位置，且难以维护



在以上对比中，由于图片过大而导致请求时间过长，而在实际应用中一般很少存在有如此之大的雪碧图，所以在请求时间上相比于HTTP/2可能没有过大的优势，但是考虑上它的维护成本，在HTTP/2时代雪碧图显然已不再被推荐，HTTP1.1时代，所有为了减少请求而做出的HACK，都已不再是HTTP/2性能优化考虑的主要点了。


问题九===========彻底讲明白浅拷贝与深拷贝
一、数据类型
数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。

1、基本数据类型的特点：直接存储在栈(stack)中的数据

2、引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里

引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

二、浅拷贝与深拷贝
深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。
浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

浅拷贝的实现方式
1. Object.assign()

let obj = {
   username: 'kobe'
};
let obj2 = Object.assign({},obj);
obj2.username = 'wade';
console.log(obj);//{username: "kobe"}
2. Array.prototype.concat()

let arr = [1, 3, {
   username: 'kobe'
}];
let arr2=arr.concat();    
arr2[2].username = 'wade';
console.log(arr);//{0: 1
                    1: 3
                    2: {username: 'wade'}}
3. Array.prototype.slice()

let arr = [1, 3, {
   username: ' kobe'
}];
let arr3 = arr.slice();
arr3[2].username = 'wade'
console.log(arr);


深拷贝的实现方式
1. JSON.parse(JSON.stringify())
2. 手写递归方法
 function clone(Obj) {   
        var buf;   
        if (Obj instanceof Array) {   
            buf = [];  //创建一个空的数组 
            var i = Obj.length;   
            while (i--) {   
                buf[i] = clone(Obj[i]);   
            }   
            return buf;   
        }else if (Obj instanceof Object){   
            buf = {};  //创建一个空对象 
            for (var k in Obj) {  //为这个对象添加新的属性 
                buf[k] = clone(Obj[k]);   
            }   
            return buf;   
        }else{   
            return Obj;   
        }   
    }  

https://www.jianshu.com/p/35d69cf24f1f


function clone(data){
  if(typeof data==='symbol'){           //Symbol
    return Symbol.for(data.description);
  }else if(typeof data!='object'){      //基本类型
    return data;
  }else if(data instanceof Array){      //Array
    return data.map(item=>clone(item));
  }else if(data.constructor===Object){   //Json
    let res={};
    for(let key in data){
      res[key]=clone(data[key]);
    }
    return res;
  }else{                                //系统对象、自定义对象
    return new data.constructor(data);
  }
}
 
原文链接：https://blog.csdn.net/qq_40735186/article/details/117225032

问题十============================add(1, 2, 3)与add(1)(2)(3)的写法

 add(1, 2, 3, ...)是对传入参数的求和方法

function add (...args) {
    return args.reduce((prev, val) => {
        return prev + val
    })
}
 
let rs = add(1, 2, 3, 4, 5, 6)
console.log(rs)  // 21
add(1)(2)(3)是一个无限累加的函数add方法，都是将函数作为返回值输出，然后接收新的参数并进行计算。

 

我们知道打印函数时会自动调用 toString()方法，函数 add(a) 返回一个闭包 sum(b)，
函数 sum() 中累加计算 a = a + b，只需要重写sum.toString()方法返回变量 a 就可以了

闭包实现:
function add (a) {
    function sum(b) { // 使用闭包
        a = a + b; // 累加
        return sum;
    }
    sum.toString = function() { // 重写toSting() 方法
        return a;
    }
    return sum; // 返回一个函数
}
 
console.log(add(1)(3)) // 4
console.log(add(1)(3)(5)) // 9


函数参数个数定长的柯里化解决方案

// 定长参数
function add (a, b, c, d) {
	return [
	  ...arguments
	].reduce((a, b) => a + b)
}

function currying (fn) {
	let len = fn.length
	let args = []
	return function _c (...newArgs) {
		// 合并参数
		args = [
			...args,
			...newArgs
		]
		// 判断当前参数集合args的长度是否 < 目标函数fn的需求参数长度
		if (args.length < len) {
			// 继续返回函数
			return _c
		} else {
			// 返回执行结果
			return fn.apply(this, args.slice(0, len))
		}
	}
}
let addCurry = currying(add)
let total = addCurry(1)(2)(3)(4) // 同时支持addCurry(1)(2, 3)(4)该方式调用
console.log(total) // 10
函数参数个数不定长的柯里化解决方案

问题升级：那这个问题再升级一下，函数的参数个数不确定时，如何实现呢？

function add (...args) {
	return args.reduce((a, b) => a + b)
}

function currying (fn) {
	let args = []
	return function _c (...newArgs) {
		if (newArgs.length) {
			args = [
				...args,
				...newArgs
			]
			return _c
		} else {
			return fn.apply(this, args)
		}
	}
}

let addCurry = currying(add)
// 注意调用方式的变化
console.log(addCurry(1)(2)(3)(4, 5)())


https://www.imooc.com/article/302720?block_id=tuijian_wz
https://blog.csdn.net/ChauncyWu/article/details/90740733


问题十一=====================变量提升
js 代码执行过程分为两个阶段
词法分析：词法分析主要包括：分析变量声明、分析函数声明、分析形参三个部分。
执行阶段
引擎通过词法分析将我们写的js代码转成可以执行的代码，接下来才是执行。

变量提升

    console.log(a);  //undefined
    var a = 123; 

因为变量a的声明被提到了作用域顶端。上面代码编译后应该是下面这个样子


    var a;
    console.log(a)
    a = 123
    //所以输出内容为 undeifend
看一道经典面试题

console.log(v1);
var v1 = 100;
function foo() {
    console.log(v1);
    var v1 = 200;
    console.log(v1);
}
foo();
console.log(v1);
// 100  undefined 200  100
他的分析过程如下：

 //他的词法分析结果如下
 var foo = ()=>console.log(1)
 foo()
 var foo = null
 foo = ()=> console.log(2)
 foo()
// 所以执行结果如下。
函数提升
具名函数的声明有两种方式：1. 函数声明式 2. 函数字面量式
//函数声明式
function bar () {}
//变量形式声明； 
var foo = function () {}
函数 变量形式声明 和普通变量一样 提升的 只是一个没有值的变量。

函数声明式的提升现象和变量提升略有不同，函数声明式会提升到作用域最前边，并且将声明内容一起提升到最上边。

bar()

var bar = function() {
  console.log(1);
}
// 报错：TypeError: bar is not a function
bar()
function bar() {
  console.log(1);
}
//输出结果1
知识点总结
所有的声明都会提升到作用域的最顶上去。

同一个变量只会声明一次，其他的会被忽略掉或者覆盖掉。

函数声明的优先级高于变量声明的优先级，并且函数声明和函数定义的部分一起被提升。

变量提升会将当前作用域的所有变量的声明提升到程序的顶部

作用域：先在内部找，如果内部找不到，向外查找

变量提升优先级(由高到低)
变量
函数
参数
提升
参数>提升
    function foo(bar) {
        console.log(bar);
        var bar = 1;
    }
    foo(100);

运行结果：
100

函数>参数>提升
    function foo(bar) {
        console.log(bar);
        var bar = 1;

        function bar() {
            return '函数1'
        }
    }
    foo(100);

运行结果：

ƒ bar() {
return ‘函数1’
}

变量>函数>参数>提升
    function foo() {
        var bar = 300;
        console.log(bar);

        function bar() {
            return '函数1'
        }
    }
    foo();

运行结果：
300

举例：请写出代码的运行结果
1.

    var foo = function() {
        console.log(100);
    }

    function foo() {
        console.log(200);
    }
    foo();

因为变量foo的优先级大于普通函数foo()，所以运行结果为100

运行结果：
100

2.

      function c() {
        var b = 1;

        function a() {
            console.log(b);
            var b = 2;
            console.log(b);
        }
        a();
        console.log(b);
    }
    c();


先在内部找，如果内部找不到，向外查找。

运行结果：
undefined
2
1
变量提升
https://www.jianshu.com/p/24973b9db51a
JavaScript变量提升优先级
https://blog.csdn.net/weixin_40492102/article/details/103746596


脉脉
typecScript
hooks主要解决什么事情，和state不同，引用hooks组件的子组件也会渲染
1.状态复用
2.复杂组件变得难以理解，代码复用成本高(高阶函数容易使代码量巨增)
3.this指向问题

雪碧图=>base64 => 打包到css =>http2 同域名，增大并发量
https://www.cnblogs.com/zhouyingying/p/11413635.html
https://zhuanlan.zhihu.com/p/26559480
懒加载=>webpack 把import转换成require
React.lazy懒加载组件
1. React.lazy的用法
React.lazy方法可以异步加载组件文件。
const Foo = React.lazy(() => import('../componets/Foo));
React.lazy不能单独使用，需要配合React.suspense，suspence是用来包裹异步组件，添加loading效果等。
<React.Suspense fallback={<div>loading...</div>}>
    <Foo/>
</React.Suspense>
2. React.lazy原理
React.lazy使用import来懒加载组件，import在webpack中最终会调用requireEnsure方法，动态插入script来请求js文件，类似jsonp的形式。
前端设计模式ICO
单例、策略、代理、装饰者、组合、工厂、访问者、观察者、发布订阅
跨端通讯=url

贝壳
1.lodash
2.ES6 常用算法，与ES5区别
区别/系统库的引用 ES5中的引用需要先使用require导入包，成为对象，再去进行真正引用
导出及引用单个类 ES5中，要导出一个类给别的模块使用，一般通过module.exports来实现，引用时通过require方法来获取
ES5的继承实质上是先创建子类的实例对象this，然后再将父类的方法添加到this上（Parent.apply(this)），然后继承原型。 ES6的继承机制完全不同，它是在子类的构造器中先调用super方法，创建出父类实例对象this，然后再去修改子类中的this完善子类
算法:
const 与 let 变量
模板字面量 ``
解构 在ES6中,可以使用解构从数组和对象提取值并赋值给独特的变量;解构数组的值:
const point = [10, 25, -34];
const [x, y, z] = point;
console.log(x, y, z);
for...of循环
for...in 
展开运算符 展开运算符（用三个连续的点 (...) 表示）是 ES6 中的新概念，使你能够将字面量对象展开为多个元素
ES6箭头函数
箭头函数是匿名函数，不能作为构造函数，不能使用new
箭头函数不绑定arguments，取而代之用rest参数...解决
箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
箭头函数通过 call()  或   apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响。
箭头函数没有原型属性
箭头函数不能当做Generator函数,不能使用yield关键字
3.单页面应用/多页面应用
组件公用的资源只需要加载一次
每个页面都要自己加载公用的资源
4.淘宝的流式布局 
https://www.cnblogs.com/yanayana/p/7066948.html
5.移动端和pc端一套代码，大小不一致如处理（用css解决）
6.css3 伪类
CSS3新增伪类举例：
p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。
:enabled  :disabled 控制表单控件的禁用状态。
:checked        单选框或复选框被选中。


http2多路复用指的是什么?

一、在http1.1中，发起一个请求是这样的:浏览器请求url->解析域名->建立http链接->服务器处理文件->返回数据->浏览器解析、处理文件
这个流程最大问题是，每次请求都需要建立一次http链接，也就是我们所说的三次握手四次挥手，这个过程是在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的。因为不间断的请求数据，第一次建立的连接是正常的，以后就占用这个通道，下载其它文件，效率会非常高。
为了解决这个问题，http1.1中提供了keep-Alive，允许我们建立一次HTTP连接，来返回多次请求的数据。
但是这里有两个问题:
1)HTTP1.1基于串行的文件传输数据，因此这些请求必然是有序的，所以实际上我们只是节省了建立连接的时间，而获取的时间并没有减少。
2)最大并发数问题，假设我们在Apache中设置最大并发数300，而因为浏览器本身的限制，最大请求数为6，那么服务器能承载的最高并发数是50，当第51个人访问时，就需要等待前面的某个请求处理完成。
而HTTP/2引入了二进制数据帧和流的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱情况。同样是因为有了序列，浏览器就可以并行的传输数据。
HTTP/2对于同一域名下所有请求都是基于流的，也就是说同一域名下不管访问多少文件，也只建立一路连接，同样Apache的最大连接数为300，因此有了这个特性，最大的并发就可以提升到300，比原来提升6倍
Http/2采用二进制格式传输，取代了Http1.X的文本格式，二进制格式更高效。多路复用代替了HTTP1.X的序列和阻塞机制，所有的相同域名的请求都通过同一个TCP连接并发完成。在HTTP1.X中，并发请求需要多个TCP连接，浏览器为了控制资源都会有6-8个TCP连接限制。
HTTP2中:
1.相同域名所有通讯都是在单个连接上完成，消除了多个TCP连接带来的延时和内存消耗。
2.单个连接上可以并行交错的请求和响应，之间互不干扰



说一说REACT逻辑状态复用问题

1.Mixins
虽然React本身有些函数式的味道，但是为了迎合用户习惯，早期只提供React.createClass()API来定义组件，自然而然地，(类)继承就成了一种直觉性尝试，而在JavaScrip基于原型的扩展模式下，类似于继承的Mixins方案自然就成了首选:
// 定义Mixin
var Mixin1 = {
  getMessage: function () {
    return "hello world";
  },
};
var Mixin2 = {
  componentDidMount: function () {
    console.log("Mixin2.componentDidMount()");
  },
};
// 用Mixin来增强现有组件
var MyComponent = React.createClass({
  mixins: [Mixin1, Mixin2],
  render: function () {
    return <div>{this.getMessage()}</div>;
  },
});
但是存在诸多缺陷:
组件与Mixins之间存在隐式依赖(Mixins经常依赖组件的特定方案，但是定义组件的时候并不知道这种依赖关系)，多个Mixin只见可能产生冲突(比如定义了相同的state字段)，Mixins倾向于增加更多状态，这降低了组件的可预测性，导致复杂程度剧增。
隐私依赖将导致依赖关系不透明，维护成本迅速攀升;难以理解的组件行为，需要全盘了解所有依赖Mixins的扩展行为，以及之间的影响。组件自身的方法和state字段也不敢轻易删改，因为难以确定有没有Mixin依赖它Mixin也难以维护，因为Mixin逻辑最后会被平台合并到一起，很难搞清除一个Mixin的输入输出。
所以，ReactV0.13.0放去了Mixin(集成)，转而走向了HOC(组合)
二Higher-Order Commponets  高阶组件
// 定义高阶组件
var Enhance = (ComposedComponent) =>
  class extends Component {
    constructor() {
      this.state = { data: null };
    }
    componentDidMount() {
      this.setState({ data: "Hello" });
    }
    render() {
      return <ComposedComponent {...this.props} data={this.state.data} />;
    }
  };
class MyComponent {
  render() {
    if (!this.data) return <div>Waiting...</div>;
    return <div>{this.data}</div>;
  }
}
// 用高阶组件来增强普通组件，进而实现逻辑复用
export default Enhance(MyComponent);
理论上，只要接受组件类型参数并返回一个组件的函数都是高阶组件((Component,...args)=>Component)，但是为了方便组合，推荐Component=>Component形式的HOC，通过偏函数来传递其它参数，例如React Redux's connect const ConnectComment=connect(commentSelector，commentActions)(CommentList)
优点:组件树结构，
降低耦合和复杂度
代码复用，逻辑抽象化
渲染劫持，属性代理，劫持组件的props和state
装饰器，可以作为装饰器来使用(装饰器的作用就是为已经存在的函数或对象添加额外的功能。装饰器应用场景及理解：装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能)
函数柯里化
缺点:
扩展性限制
不要在render中使用，因为每次renser就会创建一个高阶函数，导致组件和子组件状态丢失，影响性能
静态方法会丢失，新组件有静态方法，需要手动处理
refs不会往下传递，需要使用forwardRef
多次嵌套，增加复杂度和理解成本
未使用命名空间的话，可能会出现重命名冲突，覆盖旧属性
不可见性，不知道外面包了什么
三Render Props
“render prop”是指一种在React组件之间使用的一个值为函数的props共享代码的简单技术
class Mouse extends React.Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.state = { x: 0, y: 0 };
  }
  handleMouseMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY,
    });
  }
  render() {
    return (
      <div style={{ height: "100%" }} onMouseMove={this.handleMouseMove}>
        {/* Instead of providing a static representation of what <Mouse> renders, use the `render` prop to dynamically determine what to render. */}
        {this.props.render(this.state)}
      </div>
    );
  }
}
优点:数据共享，代码复用。将组件的state作为props传递给调用者，将渲染逻辑交给调用者
缺点:无法在return语句外访问数据，嵌套写法不够优雅
四 Hooks
function MyResponsiveComponent() {
  const width = useWindowWidth();
  // Our custom Hook
  return <p>Window width is {width}</p>;
}
function useWindowWidth() {
  const [width, setWidth] = useState(window.innerWidth);
  useEffect(() => {
    const handleResize = () => setWidth(window.innerWidth);
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  });
  return width;
}
比起上面提到的其它方案，Hooks可以让组件逻辑复用不必再与组件复用捆绑在一起，是真正从下层去尝试解决(组件间)细粒度逻辑的复用问题
此外，此种声明式逻辑复用方案将组件间的显示数据流与组合思想进一步延伸到了组件内，契合react理念
优点如下:
解决嵌套问题，简介，代码量更少，React Hooks解决了HOC和Render Props的嵌套问题，更加简洁
解耦:React Hooks可以更方便的把UI和状态分离，做到更彻底的解耦
解决类组件的3个问题:React Hooks为函数组件而生，:
this指向问题
(state)业务逻辑被分割在不同的声明周期，是的代码难以理解和维护
代码复用成本高(高阶函数容易使代码量巨增)
Hooks也并非完美，缺点如下:
1.还有两个类组件生命周期不能用hooks替代，getSnapshotBeforeUpdate(在更新真实DOM之前获取一个快照，这个钩子也可以接受两个参数一个props和一个state，不同的是，这两个参数都是上一时刻，也就是此次更新前那一时刻的props和state。可以有一个返回值，这个返回值会被componentDidUpdate的第三个参数接受到)和componentDidCatch
2.额外的学习成本
3.写法上有限制，不能再条件，循环，嵌套函数中试用，只能在函数顶层试用，增加了重构旧代码的成本，因为react需要利用顺序来更新状态和调用钩子函数；放在循环或者条件分支之中，可能会导致调用顺序不一致，导致奇怪的bug
破坏了PureComponent，React.mome浅比较的性能优化效果(为了取最新的props和state，每次render()都要重新创建事件处理函数)
在闭包场景可能会引用到旧的state，props，值内部实现不直观
React.memo并不能完全替代shouldComponentUpdate(因为拿不到state change，只针对props change)
useState AP设计上不太完美
使用UseState时，数组对象，使用push，pop，slice直接更新无效，比如let [nums，setNums]=useState([0,1,2]);
num.push(1)无效，必须使用nums=[...num，1]，再setNums(nums),类组件中直接push是没问题的，
不能使用装饰器
函数组件refs需要forwardRef


React组件通信方式
1.父组件向子组件通信
通过props
2.子组件向父组件通信
props+回调
3.跨级组件通信
props+中间件传递
context 通过createContext创建，Provider提供，Consumer访问
4.非嵌套关系的组件通信
自定义事件(发布订阅模式)
可以通过redux等全局状态管理
兄弟之间的，可以找到共同父节点，结合父子通信



function myCounterReducer(state = { count: 0 }, action) {
  switch (action.type) {
    case 'add':
      return state.set('count', state.get('count') + 1);
    default:
      return state;
  }
}

菲波那切数列即：1 1 2 3 5 8......，后面的数字是前面两个数字的和，并且第一个，第二个数字都是1，用js实现

的两种方法，一种通过常用的递归调用，第二种不通过递归，而是通过强大的闭包实现。

1.递归实现

 // fab 1 1 2 3 5 8
            function fab(num) {
                if(num==1 || num==2){
                    return 1;
                }else{
                    return fab(num-1)+fab(num-2);
                }
            }
            alert(fab(5))
 

2.闭包实现。闭包主要在于：1.模拟面向对象 封装数据 2.保存数据，因为如果把i，j定义在函数外面，将成为全局变量，不安全，因为会被调用修改，而

用闭包可以很好的封装数据，不用递归一样可以实现同样的功能，更常用。

 //闭包1.模拟面向对象  封装数据2.保存数据
            var fib = (function () {
                var i = 1;
                var j = 1;
                return function (n) {
                    var res = j;
                    for (var k = 3; k <= n; k++) {
                        res = i + j;
                        i = j;
                        j = res;
                    }
                    return res;
                }
            })();
            document.write(fib(5));


 public int climbStairs(int n) {
    if ( n == 1) {
       return 1;
    }
    int first = 1;
    int second = 2;
    for (int i = 3; i <= n; i++) {
        int third = first + second;
        first = second;
        second = third;
    }
    return second;
}
  

  
let gender = 'female';
console.log('Lily is a ' + (gender === 'female') ?
            ‘girl.' : ‘boy.');



静态布局、自适应布局、流式布局、响应式布局、弹性布局等的概念和区别
一、静态布局（Static Layout）
即传统Web设计，网页上的所有元素的尺寸一律使用px作为单位。

1、布局特点：不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的pc的网站都是静态（定宽度）布局的，也就是设置了min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见与pc端。
2、设计方法：
　　PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；
　　移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如wap.或m.。

　   在移动端开发中采用静态布局的两种方式：(来自：流布局与响应式网页设计有什么区别？)

　（1）在viewport meta标签上设置width=320，页面的各个元素也采用px作为单位。通过用JS动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。（见前端开发-web app 变革之rem）

　（2）设在viewport meta标签上设置content"width=640,user-scalable=no，页面的各个元素也采用px作为单位。由于640px超出了手机宽度，浏览器会自动缩小页面至刚好全屏。（具体见content"width=640,user-scalable=no" 然后再进行固定尺寸的px设计？ - 前端开发）

优点：这种布局方式对设计师和CSS编写者来说都是最简单的，亦没有兼容性问题。

缺点：显而易见，即不能根据用户的屏幕尺寸做出不同的表现。

当前，大部分门户网站、大部分企业的PC宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。

二、流式布局（Liquid Layout）

流式布局（Liquid）的特点（也叫"Fluid") 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。

网页中主要的划分区域的尺寸使用百分数（搭配min-*、max-*属性使用），例如，设置网页主体的宽度为80%，min-width为960px。图片也作类似处理（width:100%, max-width一般设定为图片本身的尺寸，防止被拉伸而失真）。

1、布局特点：屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示】

2、设计方法：使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。

这种布局方式在Web前端开发的早期历史上，用来应对不同尺寸的PC屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式，但缺点明显：主要的问题是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用px来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调。

三、自适应布局（Adaptive Layout）
自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个系列。
1、布局特点：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。
2、设计方法：使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。

四、响应式布局（Responsive Layout）

随着CSS3出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的PC、手机、手表、冰箱的Web浏览器等等）都能显示出令人满意的效果，对CSS编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。

响应式几乎已经成为优秀页面布局的标准。

1、布局特点：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。

2、设计方法：媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。

优点：适应pc和移动端，如果足够耐心，效果完美

缺点：（1）媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。（2）要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。

因此，Set 很容易实现交集（Intersect）、并集（Union）、差集（Difference）
let set1 = new Set([1, 2, 3])
let set2 = new Set([4, 3, 2])
let intersect = new Set([...set1].filter(value => set2.has(value)))
let union = new Set([...set1, ...set2])
let difference = new Set([...set1].filter(value => !set2.has(value)))


BFC(块级格式化上下文)
3.如何创建BFC
（1）float不为none
（2）position不为static或relative
（3）display为inline-block或是table相关
（4）overflow不为visible
4.BFC的使用场景
（1）解决垂直方向的边距重叠
（2）清除浮动
（3）不与浮动元素重叠
————————————————
版权声明：本文为CSDN博主「低调的小犬_Hansen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_38588845/article/details/104566707


五分钟掌握网格布局（grid）常用属性
https://blog.csdn.net/csdn_zsdf/article/details/81630446


1、DOM结构
display：会让元素完全从渲染树中消失，渲染的时候不占据任何空间，不能点击。
visibility：不会让元素从渲染树消失，元素继续占据空间，只是内容不可见，不能点击。
opacity：不会让元素从渲染树消失，元素继续占据空间，只是内容不可见，可以点击。
2、继承
display：非继承属性，子孙节点不被渲染，子孙节点修改属性不改变本身显隐。
visibility：继承属性，子孙节点的消失由于继承了hidden，通过设置visibility: visible，可以让子孙节点显示。
opacity：继承属性，子孙节点会继承，但是子孙节点修改属性不改变本身显隐。
3、性能
display：动态改变此属性时会引起重排，性能较差。
visibility：动态改变此属性时只会引起本元素重绘，性能较好
opacity：提升到合成层后，不会触发重绘，否则只引起本元素重绘，性能较好
4、transition
display：不支持
visibility：会立即显示，隐藏时会延时
opacity：可以延时显示和隐藏，产生渐显渐隐

定义和用法
reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
reduce() 可以作为一个高阶函数，用于函数的 compose。


webpack怎么把背景图片打包成base64替换到css中？
css需要通过插件进行提取
图片可以通过url-loader来进行处理，设置小于某个大小的进行base64编码


js中的堆内存与栈内存
在js引擎中对变量的存储主要有两种位置，堆内存和栈内存。
和java中对内存的处理类似，栈内存主要用于存储各种基本类型的变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。
而堆内存主要负责像对象Object这种变量类型的存储，

简述 react 生命周期
页面初始化：constructor-->componentWillMount-->render-->componentDidMount
父级数据更新：componentWillReceiveProps-->shouldComponentUpdate-->componentWillUpdate-->render-->componentDidUpdate
组件数据更新：shouldComponentUpdate-->componentWillUpdate-->render-->componentDidUpdate
强制更新：componentWillUpdate-->render-->componentDidUpdate

简述 HTTP 
HTTP是基于客户/服务器模式，且面向连接的。典型的HTTP事务处理有如下的过程：
（1）客户与服务器建立连接；
（2）客户向服务器提出请求；
（3）服务器接受请求，并根据请求返回相应的文件作为应答；
（4）客户与服务器关闭连接。

简述响应式布局
响应式布局的诞生背景:移动弄互联网的兴起促使让不同设备显示出相同的网页效果效果成为必要。
什么是响应式布局
响应式设计的优缺点:
优点：
解决了设备之间的差异化展示
缺点：
兼容性代码多，工作量大，加载速度受影响。(可忽略)
响应式设计的原则
1、移动设备优先：在设计初期就要考虑页面如何在多终端显示
2、渐进增强：充分发挥硬件设备的最大功能
例如IE6、7、8不支持css3的属性，需要用js实现响应式布局，但是对于高级浏览器，我们就可以使用css3来实现，充分发挥浏览器的性能。
如何实现响应式布局
大概有三种方式实现：
1、CSS3-Media Query(最简单的方式)
2、第三方开源框架(如bootstrap，可以很好的支持浏览器响应式布局的设计)
3、借助原生JavaScript(IE6、7、8，成本高，不推荐使用)

简述 webpack 中的 loader
loader：是webpack用来预处理模块的，在一个模块被引入之前，会预先使用loader处理模块的内容，在你打包的时候对某些内容需要loader来处理一下，比如css模块；默认webpack只会处理js代码，所以当我们想要去打包其他内容时，就需要相应的loader去处理某些内容

react 生命周期 有几个 常用几个 componentDidMount 调用几次 
react中， 当你排除其他props更新两次 且在你运行的时候构造函数和render函数都只调用的了一次，而componentDidMount函数却在后面连续执行了两次，只需要在index.tsx文件中把严格模式组件 React.StrictMode给删掉就可以了， 这是一个经典的问题。

css 里的弹性布局常用做什么
1.flex-direction元素
flex-direction 属性规定灵活项目的方向,分为行和列布局方式。
而项目就是容器成员，称为Flex项目（item），简称”项目”。
flex-direction 可以有不同的属性值：
row： 默认值。灵活的项目将水平显示，如本例中项目从右到左水平展示。
row-reverse： 与 row 相同，但是以相反的顺序。
加粗样式 灵活的项目将垂直显示。
column-reverse： 与 column 相同，但是以相反的顺序。
initial： 设置该属性为它的默认值。
inherit： 从父元素继承该属性

盒模型怎么平分居中 
方法一
绝对定位：position：absolute；
方法二
margin：50% auto；
方法三
伸缩盒布局：在父元素上设置display:flex;
justify-content:center; 水平主轴对齐方式
align-items:center; 竖直轴线方向


css 动画(transition,anmiation) 
　先区分一下css中的几个属性：animation（动画）、transition（过渡）、transform（变形）、translate（移动）。
　　CSS3中的transform(变形)属性用于内联元素和块级元素，可以旋转、扭曲、缩放、移动元素，它的属性值有以下五个：旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix；
　　transform(变形)是CSS3中的元素的属性，而translate只是transform的一个属性值；transform是transition（过渡动画）的transition-property的一个属性值。
　　animation（动画）、transition（过渡）是css3中的两种动画属性。animation强调流程与控制，对元素的一个或多个属性的变化进行控制，可以有多个关键帧（animation 和@ keyframes结合使用）；
　　transition强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（例如hover）时才能获取样式，这样就会产生过渡动
https://www.cnblogs.com/shenfangfang/p/5713564.html
画。可以认为它有两个关键帧（Transition ＋ Transform ＝ 两个关键帧的Animation）。
es6 的常用知识点 const 和 let 区别， 结构 ，async await ,class ,箭头函数
js 里面的栈和堆的理解 
一、  堆(heap)和栈(stack)
栈(stack)会自动分配内存空间，会自动释放。堆(heap)动态分配的内存，大小不定也不会自动释放
二、数据类型
1、基本类型(简单的数据段，存放在栈里面，占固定大小的空间)
基本类型有：Undefined、Null、Boolean、Number 和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。
2、引用类型(多个值构成的对象，保存在堆内存中，包含引用类型的变量实际上保存的不是变量本身，而是指向该对象的指针)
引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。 这样，当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。
三、数据销毁
基本数据类型在当前执行环境结束时销毁，而引用类型不会随执行环境结束而销毁，只有当所有引用他的变量不存在时这个对象才会被回收机制回收。

webpack 的使用
一、什么是 webpack
webpack 是一个模块打包机，将根据文件间的依赖关系对其进行静态分析，然后将这些模块按指定规则生成静态资源
当 webpack 处理程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle
主要承担如下功能：
打包：将多个文件 打包成 一个文件，减少服务器压力和下载带宽
转换：将预编译语言 转换成 浏览器识别的语言
优化：性能优化
webpack 特点：
代码拆分
webpack 有两种组织模块的依赖方式，同步、异步
异步依赖将作为分割点，形成一个新的块；在优化了依赖树之后，每一个异步区块都将作为一个文件被打包
智能解析
webpack 有一个智能解析器，几乎可以处理任何第三方库
无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件；甚至在加载依赖的时候，允许使用动态表达式 require("./templates/" + name + ".jade")
快速运行
webpack 使用异步 I/O 、多级缓存提高运行效率，使得 webpack 以难以令人置信的速度 快速增量编译


1.状态码 403 301 302 都是什么意思 
301（永久移动）
请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。
302（临时移动）
服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。
400（错误请求）
服务器不理解请求的语法。
401（未授权）
请求要求身份验证。对于登录后请求的网页，服务器可能返回此响应。
403（禁止）
服务器拒绝请求。如果您在 Googlebot 尝试抓取您网站上的有效网页时看到此状态码（您可以在 Google 网站管理员工具诊断下的网络抓取页面上看到此信息），可能是您的服务器或主机拒绝了 Googlebot 访问。
404（未找到）
服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。
如果您的网站上没有 robots.txt 文件，而您在 Google 网站管理员工具“诊断”标签的 robots.txt 页上看到此状态码，则这是正确的状态码。但是，如果您有 robots.txt 文件而又看到此状态码，则说明您的 robots.txt 文件可能命名错误或位于错误的位置（该文件应当位于顶级域，名为 robots.txt）。
如果对于 Googlebot 抓取的网址看到此状态码（在”诊断”标签的 HTTP 错误页面上），则表示 Googlebot 跟随的可能是另一个页面的无效链接（是旧链接或输入有误的链接）。
500（服务器内部错误）
服务器遇到错误，无法完成请求。
501（尚未实施）
服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码。
502（错误网关）
服务器作为网关或代理，从上游服务器收到无效响应。
503（服务不可用）

服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。
2.一个由十万个元素组成的数组，取出第一个和最后一个元素，他们时间差是 多少，为 什么
数组可以直接根据索引取的对应的元素，所以不管取哪个位置的元素的时间复杂度都是 O(1)
得出结论：消耗时间几乎一致，差异可以忽略不计
3.手写防抖和截流 
4.请说出 for of 和 for in 得区别，并对数组和对象进行遍历 
5.给定一个数组，分别求和，排序和去重
vue 和 react 区别 
es6 用 过哪些东西 
computed 和 watch 区别
功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。
是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。
是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。
computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）
使用场景：computed----当一个属性受多个属性影响的时候，使用computed-----购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch-----搜索框.
1、左右固定中间自适应 2、盒子水平垂直居中 3、一个 margin 是 30 一个 margin 是 20，在一起时他们的距离是多少 4、localStorage 和 sessionStorage 的区别和应用
5、webpack 的 loader 配置和加载顺序 
6、react 新增的生命周期，容器组件如何建立 
React 组件生命周期
在本章节中我们将讨论 React 组件的生命周期。
组件的生命周期可分成三个状态：
Mounting(挂载)：已插入真实 DOM，cons
Updating(更新)：正在被重新渲染
Unmounting(卸载)：已移出真实 DOM
7、react的性能优化在哪个生命周期？它优化的原理是什么？
shouldComponentUpdate
减少不必要的重新渲染 


es6 的 set 和 map 数据结构是什么样的？
ES6提供了新的数据结构Set。类似于数组，只不过其成员值都是唯一的，没有重复的值。 
Set本身是一个构造函数，用来生成Set数据结构。
Js对象本质上是键值对的集合。但是只能使用字符串充当键。这在一定程度上给我们的使用带来很大的限制。

var data = {};
var element = document.getElementById("myDiv");

// 将DOM节点（即element）当做对象data的键.
// 但是对象只接受字符串作为键名，所以element被自动转换为字符串"[Object HTMLDivElement]"
data[element] = metadata;
而ES6正是为了解决这个问题才提供了Map结构。它类似与对象，也是键值对集合，但是”键”的范围不限于字符串，对象也可以当作键。

var m = new Map();
o = {p: "hello world"};

m.set(o, "content");
console.log( m.get(o) );  // content
在上面的代码中，将对象o当作m的一个键。

Map函数可接收一个数组进行初始化。

var map = new Map([["name", "小明"], ["title", "Author"]]);

map.size //2
map.has("name"); //true
map.get("name"); //小明
map.has("title"); //true
map.get("title"); //Author

注意：只有针对同一个对象的引用，Map结构才将其视作同一个键。这一点要非常小心才行。
————————————————
版权声明：本文为CSDN博主「Dragon_GL」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/u014695532/article/details/51815017
common.js 前端的使用？
写代码问题是从数组取出特定元素要求用多种方法；
 讲一下 js 当中的 event loop
 详细步骤如下：
　　1、所有同步任务都在主线程上执行，形成一个执行栈
　　2、主线程之外，还存在一个"消息队列"。只要异步操作执行完成，就到消息队列中排队
　　3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
　　4、主线程不断重复上面的第三步
【循环】
　　从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。
　　由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环


js解决0.1+0.2==0.3的问题的几种方法
JavaScript有7种基本类型分别是: Undefined, Null, Boolean, String, Number, Symbol, Object.

对于JS中的Number类型, 不区分整数和浮点数, 浮点数的精度远远不如整数, 首先先看一下为什么会出现这个问题, 根据双精度浮点数的定义, Number类型的有效整数范围是-0XFFFFFFFFFFF至0X1FFFFFFFFFF,所以无法精确到超过这个范围的整数.

解决办法
1.ES6提供的Number.EPSILON方法

function numbersequal(a,b){ return Math.abs(a-b)<Number.EPSILON;
} 
var a=0.1+0.2， b=0.3;
console.log(numbersequal(a,b)); //true
考虑兼容性的问题了，在chrome中支持这个属性，但是IE并不支持(笔者的版本是IE10不兼容)，所以我们还要解决IE的不兼容问题。

Number.EPSILON=(function(){   //解决兼容性问题
        return Number.EPSILON?Number.EPSILON:Math.pow(2,-52);
      })();
//上面是一个自调用函数，当JS文件刚加载到内存中，就会去判断并返回一个结果，相比if(!Number.EPSILON){
  //   Number.EPSILON=Math.pow(2,-52);
  //}这种代码更节约性能，也更美观。
function numbersequal(a,b){ 
    return Math.abs(a-b)<Number.EPSILON;
  }
//接下来再判断   
    var a=0.1+0.2, b=0.3;
  console.log(numbersequal(a,b)); //这里就为true了
2.把计算数字 提升 10 的N次方 倍 再 除以 10的N次方。N>1.


为什么0.1+0.2不等于0.3？原来编程语言是这么算的……
https://zhuanlan.zhihu.com/p/87672024

原型规则
1.所有的引用类型（数组、对象、函数）都具有对象特性，即可自由扩展属性（除了“null”）
2.所有的引用类型（数组、对象、函数）都有一个 _proto_ 属性(隐式原型属性），属性值是一个普通的对象
3.所有的函数，都有一个 prototype(显式原型）属性，属性值也是一个普通的对象
4. 所有的引用类型（数组、对象、函数）， _proto_ 属性值(隐式原型属性）指向它的构造函数的“prototype”属性值
6.循环对象自身的属性
 当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的_proto_(即它的构造函数的 prototype（显式原型）)中寻找
————————————————
版权声明：本文为CSDN博主「姜皓」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jianghao233/article/details/80274779
原型（对象属性）
Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。
prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。
prototype就是调用构造函数所创建的那个实例对象的原型（proto）。
prototype可以让所有对象实例共享它所包含的属性和方法。也就是说，不必在构造函数中定义对象信息，而是可以直接将这些信息添加到原型中。
原型链 （JS原型与原型链继承）
实例对象与原型之间的连接，叫做原型链。proto( 隐式连接 )
JS在创建对象的时候，都有一个叫做proto的内置属性，用于指向创建它的函数对象的原型对象prototype。
内部原型(proto)和构造器的原型（prototype）
1、每个对象都有一个proto属性,原型链上的对象正是依靠这个属性连结在一起
2、作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个 方法或属性，那么Javascript引擎将会访问这个对象的proto属性所指向上一个对 象，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象 的proto属性指向的对象进行向上查找，直到这个链表结束。

作者：感觉不错哦
链接：https://www.jianshu.com/p/72156bc03ac1
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

滚动条下拉底部，图片显示不全->怪异盒模型，把margin计算在内

微前端项目中样式隔离方案
基于qiankun的微前端项目，虽然官方提供了基于shadowDom的样式隔离方案，但该方案仍不完善。所以做一下几点约束，达成规范：
各主/子应用，若是基于antd的ui框架，各自修改css class的前缀
项目中的less全部采用css module形式，不能使用全局引入less文件方式书写可能影响布局、字号等关键参数
采用以上两点约束，基本可以达成样式隔离的效果。
https://www.yuque.com/techiu/vkrpan/urz482


call 和 apply 特性一样

都是用来调用函数，而且是立即调用
但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向
call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可
apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递
如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window
bind

可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数
它和 call、apply 最大的区别是：bind 不会调用
bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递
在 bind 的同时，以参数列表的形式进行传递
在调用的时候，以参数列表的形式进行传递
那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准
两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部
简单的说
call的参数是直接放进去的，第二第三第n个参数全都用逗号分隔，直接放到后面
apply的所有参数都必须放在一个数组里面传进去
bind除了返回是函数以外，它 的参数和call 一样(需要用小括号调用函数)
————————————————
版权声明：本文为CSDN博主「灯火暗」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/denghuocc/article/details/89157308

手动实现观察者模式或者发布、订阅者模式
https://www.cnblogs.com/lovesong/p/5272752.html
求[11,5,6,9,45,2]最大差值和最小差值
reduce
求"11,3,4,5,677,7,8,4,51,1,456,65,1"最大连续值集合
 var arr = [11,3,4,5,677,7,8,4,51,1,456,65,1];
        function findSum(arr){
            var currentSum = 0;
            var maxSum = 0;
            for(var i = 0;i<arr.length;i++){
                if(currentSum+arr[i]>=arr[i]){
                    currentSum = currentSum+arr[i];
                }else{
                    currentSum = arr[i];
                }
                if(currentSum>=maxSum){
                    maxSum=currentSum
                }else{
                    maxSum = maxSum;
                }
            }
描述下BFC/IFC
介绍下session和cookie

手写:
Promise.all = arr => {
    let aResult = [];    //用于存放每次执行后返回结果
    return new _Promise(function (resolve, reject) {
      let i = 0;
      next();    // 开始逐次执行数组中的函数(重要)
      function next() {
        arr[i].then(function (res) {
          aResult.push(res);    // 存储每次得到的结果
          i++;
          if (i == arr.length) {    // 如果函数数组中的函数都执行完，便resolve
            resolve(aResult);
          } else {
            next();
          }
        })
      }
    })
  };
代码扁平化代码实现
迭代的实现:
let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]]
const flatten = function (arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr)
    }
    return arr
}
console.log(flatten(arr))
递归的实现(ES6简写):
const flatten = array => array.reduce((acc, cur) => (Array.isArray(cur) ? [...acc, ...flatten(cur)] : [...acc, cur]), [])


为什么0.1+0.2不等于0.3？原来编程语言是这么算的……
https://zhuanlan.zhihu.com/p/87672024



JavaScript 中精度问题以及解决方案
想用有限的位来表示无穷的数字，显然是不可能的，因此会出现一些列精度问题：
浮点数精度问题，比如 0.1 + 0.2 !== 0.3
大数精度问题，比如 9999 9999 9999 9999 == 1000 0000 0000 0000 1
toFixed 四舍五入结果不准确，比如 1.335.toFixed(2) == 1.33
浮点数精度和 toFixed 其实属于同一类问题，都是由于浮点数无法精确表示引起的，如下：

解决思路
首先考虑的是如何解决浮点数运算的精度问题，有 3 种思路：

考虑到每次浮点数运算的偏差非常小(其实不然)，可以对结果进行指定精度的四舍五入，比如可以parseFloat(result.toFixed(12));
将浮点数转为整数运算，再对结果做除法。比如0.1 + 0.2，可以转化为(1*2)/3。
把浮点数转化为字符串，模拟实际运算的过程。
所以，最终考虑使用第三种方案，目前已经有了很多较为成熟的库，比如 bignumber.js，decimal.js，以及big.js等
https://www.runoob.com/w3cnote/js-precision-problem-and-solution.html


flex===1
4.2 flex-grow属性
flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
.item {
  flex-grow: <number>; /* default 0 */
}
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
4.3 flex-shrink属性
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
.item {
  flex-shrink: <number>; /* default 1 */
}
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
负值对该属性无效。
4.4 flex-basis属性
flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
.item {
  flex-basis: <length> | auto; /* default auto */
}
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
4.5 flex属性
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。

建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
https://www.runoob.com/w3cnote/flex-grammar.html




==：运算符称作相等，用来检测两个操作数是否相等，这里的相等定义的非常宽松，可以允许进行类型转换
===：用来检测两个操作数是否严格相等
1、对于string,number等基础类型，==和===是有区别的
不同类型间比较，==之比较“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等
同类型比较，直接进行“值”比较，两者结果一样
2、对于Array,Object等高级类型，==和===是没有区别的
3、基础类型与高级类型，==和===是有区别的
对于==，将高级转化为基础类型，进行“值”比较，因为类型不同，===结果为false
————————————————
版权声明：本文为CSDN博主「樊建华-Aric」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/fjh19950514/article/details/84198190



const fn = (data, value) => {
  let res = []
  const dfs = (arr, temp = []) => {
    for (const node of arr) {
      if (node.children) {
        dfs(node.children, temp.concat(node.id))
      } else {
        if (node.id === value) {
          res = temp
          return
        }
      }
    }
  }
  dfs(data)
  return res
}



// every只有所有元素都具备某项特性后，才会返回true，在碰到return false的时候，中止循环。
var a = [1, 2, 3, 4, 5]
a.every(item=>{
    console.log(item); //输出：1,2
    if (item === 2) {
        return false
    } else {
        return true
    }
})

//some只要有一个满足，循环就会结束，在碰到return ture的时候，中止循环。
var a = [1, 2, 3, 4, 5]
a.some(item=> {
    console.log(item); //输出：1,2
    if (item === 2) {
        return true
    } else {
        return false
    }
})