第一章 基础篇
　
​		1.1 HTML			

​				：行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？

```
行内元素：span、img、input...
块级元素：div、footer、header、section、p、h1...h6...
空元素：br、hr...


元素之间的转换问题：
display: inline;  			把某元素转换成了行内元素      ===>不独占一行的，并且不能设置宽高
display: inline-block; 	把某元素转换成了行内块元素		 ===>不独占一行的，可以设置宽高
display: block;					把某元素转换成了块元素			   ===>独占一行，并且可以设置宽高
```

页面导入样式时，使用link和@import有什么区别？

```
区别一：link先有，后有@import（兼容性link比@import兼容）；
区别二：加载顺序差别，浏览器先加载的标签link，后加载@import
```

title与h1的区别、b与strong的区别、i与em的区别？

```
title与h1的区别：

定义：
	title：概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么
	h1：文章主题内容，告诉我们的网站内容最主要是什么
区别：
	title他是显示在网页标题上、h1是显示在网页内容上
	title比h1添加的重要 (title > h1 ) ==》对于seo的了解
场景：
	网站的logo都是用h1标签包裹的	
```

```
b与strong的区别：

定义：
	b：实体标签，用来给文字加粗的。
	strong：逻辑标签，用来加强字符语气的。
区别：
	b标签只有加粗的样式，没有实际含义。
	strong表示标签内字符比较重要，用以强调的。
题外话：为了符合css3的规范，b尽量少用该用strong就行了。
```

```
i与em的区别：

定义：
	i:实体标签，用来做文字倾斜的。
	em：是逻辑标签，用来强调文字内容的
区别：
	i只是一个倾斜标签，没有实际含义。
	em表示标签内字符重要，用以强调的。
场景：
	i更多的用在字体图标，em术语上（医药，生物）。
```

img标签的title和alt有什么区别？

```
区别一：
	title ： 鼠标移入到图片显示的值
	alt   ： 图片无法加载时显示的值
区别二：
	在seo的层面上，抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图是什么内容或者关键词。
```

png、jpg、gif 这些图片格式解释一下，分别什么时候用？

```
png:无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标。
jpg:采用压缩算法，有一点失真，比png体积要小，适合做中大图片。
gif:一般是做动图的。
webp：同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好。
```

​		1.2 CSS

​				：介绍一下CSS的盒子模型

```
CSS的盒子模型有哪些：标准盒子模型、IE盒子模型
CSS的盒子模型区别：
	标准盒子模型：margin、border、padding、content
	IE盒子模型 ：margin、content（ border +  padding  + content ）
通过CSS如何转换盒子模型：
	box-sizing: content-box;	/*标准盒子模型*/
	box-sizing: border-box;	  /*IE盒子模型*/
```

line-height和heigh区别【大厂】

```
line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。
height是一个死值，就是这个盒子的高度。
```

CSS选择符有哪些？哪些属性可以继承？

```
CSS选择符：
    通配（*）
    id选择器（#）
    类选择器（.）
    标签选择器（div、p、h1...）
    相邻选择器(+)
     子元素选择器（ > ）
    属性选择器(a[href])
    
CSS属性哪些可以继承：
		文字系列：font-size、color、line-height、text-align...
***不可继承属性：border、padding、margin...
```

CSS优先级算法如何计算？

```
优先级比较：!important > 内联样式 > id > class > 标签 > 通配
```

```
CSS权重计算：
第一：内联样式（style）  权重值:1000
第二：id选择器  				 权重值:100
第三：类选择器 				  权重值:10
第四：标签&伪元素选择器   权重值:1
第五：通配、>、+         权重值:0
```

​				：用CSS画一个三角形

```
用边框画（border）,例如：
{
		width: 0;
		height: 0;

		border-left:100px solid transparent;
		border-right:100px solid transparent;
		border-top:100px solid transparent;
		border-bottom:100px solid #ccc;
}
```

一个盒子不给宽度和高度如何水平垂直居中？

##### 方式一：

```
<div class='container'>
	<div class='main'>main</div>
</div>

.container{
		display: flex;
		justify-content: center;
		align-items: center;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		background: red;
}
```

##### 方式二：

```
<div class='container'>
	<div class='main'>main</div>
</div>

.container{
		position: relative;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		position: absolute;
		left:50%;
		top:50%;
		background: red;
		transform: translate(-50%,-50%);
}
```

​				：display有哪些值？说明他们的作用。

```
none     			隐藏元素
block    			把某某元素转换成块元素
inline   			把某某元素转换成内联元素
inline-block 	把某某元素转换成行内块元素
```

​				：对BFC规范(块级格式化上下文：block formatting context)的理解？

```
BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

1. 了解BFC ： 块级格式化上下文。
2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。
3. 如何触发BFC：


BFC可以通过以下方式创建：

根元素（<html>）。
浮动元素（元素的float不是none）。
绝对定位元素（元素的position为absolute或fixed）。
display为inline-block、table-cells、flex。
overflow不是visible的块元素。
fieldset元素。

BFC的作用
BFC有一些特性，这些特性可以用于解决各种布局问题：

内部的Box会在垂直方向上一个接一个地放置。
Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。
每个元素的左外边缘与包含块的左边缘相接触（对于从右到左的格式，右边缘相接触）。
BFC的区域不会与float元素的布局区域重叠。
计算BFC的高度时，浮动元素也参与计算。
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。
BFC的应用
BFC可以用于以下场景：
防止margin重叠：相邻的块级元素垂直方向的margin会发生重叠，可以通过创建BFC来避免这个问题。
包含浮动元素（清除浮动）：未创建BFC的父元素无法自动包含其浮动的子元素，通过创建BFC可以解决外部元素高度塌陷的问题。
创建自适应两栏布局：可以利用BFC防止元素被浮动元素覆盖，从而实现两栏布局。
防止文字环绕：可以通过BFC避免文字围绕浮动元素。

```

清除浮动有哪些方式？

```
1. 触发BFC
2. 多创建一个盒子，添加样式：clear: both;
3. after方式
	ul:after{
			content: '';
			display: block;
			clear: both;
	}
```

在网页中的应该使用奇数还是偶数的字体？为什么呢？

```
偶数 : 让文字在浏览器上表现更好看。

另外说明：ui给前端一般设计图都是偶数的，这样不管是布局也好，转换px也好，方便一点。
```

position有哪些值？分别是根据什么定位的？

```
static [默认]  没有定位
fixed  固定定位，相对于浏览器窗口进行定位。
relative  相对于自身定位，不脱离文档流。
absolute	相对于第一个有relative的父元素，脱离文档流。


relative和absolute区别
1. relative不脱离文档流 、absolute脱离文档流
2. relative相对于自身 、 absolute相对于第一个有relative的父元素
3. relative如果有left、right、top、bottom ==》left、top
	 absolute如果有left、right、top、bottom ==》left、right、top、bottom
```

写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。

1. **使用浮动（Floats）**:
```css
.container {
  overflow: hidden;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
  float: left; /* 左侧栏浮动 */
}
.right {
  float: right; /* 右侧栏浮动 */
}
.center {
  margin: 0 200px; /* 中间栏的外边距等于侧栏宽度 */
}
```

2. **使用Flexbox**:
```css
.container {
  display: flex;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
}
.center {
  flex: 1; /* 中间栏占据剩余空间 */
}
```

3. **使用CSS Grid**:
```css
.container {
  display: grid;
  grid-template-columns: 200px auto 200px; /* 三列的宽度 */
}
.left {
  grid-column: 1;
}
.center {
  grid-column: 2;
}
.right {
  grid-column: 3;
}
```

4. **使用绝对定位（Absolute Positioning）**:
```css
.container {
  position: relative;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
  position: absolute;
  top: 0;
}
.left {
  left: 0;
}
.right {
  right: 0;
}
.center {
  margin: 0 200px; /* 中间栏的外边距等于侧栏宽度 */
}
```

5. **使用表格布局（Table Layout）**:
```css
.container {
  display: table;
  width: 100%;
}
.left, .center, .right {
  display: table-cell;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
}
.center {
  /* 中间栏自动填充剩余空间 */
}
```


什么是CSS reset？

```
reset.css   		是一个css文件，用来重置css样式的。
normalize.css 	为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。
```

css sprite是什么,有什么优缺点

```
1. 是什么
	把多个小图标合并成一张大图片。
2. 优缺点
	优点：减少了http请求的次数，提升了性能。
	缺点：维护比较差（例如图片位置进行修改或者内容宽高修改）
```

display: none;与visibility: hidden;的区别

```
1. 占用位置的区别
display: none; 				是不占用位置的
visibility: hidden;   虽然隐藏了，但是占用位置

1. 重绘和回流的问题

visibility: hidden; 、 display: none;  产生重绘
display: none;     还会产生一次回流

产生回流一定会造成重绘，但是重绘不一定会造成回流。

产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....
产生重绘的情况：样式改变、换皮肤
```

opacity 和 rgba区别

```
共同性：实现透明效果

1. opacity 取值范围0到1之间，0表示完全透明，1表示不透明
2. rgba   R表示红色，G表示绿色，B表示蓝色，取值可以在正整数或者百分数。A表示透明度取值0到1之间

区别：继承的区别
opacity会继承父元素的opacity属性，而RGBA设置的元素的后代元素不会继承不透明属性。
```

​		1.3 JavaScript基础

​				：延迟加载JS有哪些方式？

```
延迟加载：async、defer
		例如：<script defer type="text/javascript" src='script.js'></script>
		
defer : 等html全部解析完成，才会执行js代码，顺次执行js脚本。
async : async是和html解析同步的（一起的），不是顺次执行js脚本（谁先加载完谁先执行）。
```

​				：JS数据类型有哪些？

```
基本类型：string、number、boolean、undefined、null、symbol、bigint
引用类型：object

NaN是一个数值类型，但是不是一个具体的数字。
```

​				：JS数据类型	

##### 一：

```
console.log( true + 1 );     			//2
console.log( 'name'+true );  			//nametrue
console.log( undefined + 1 ); 		//NaN
console.log( typeof undefined ); //undefined
```

##### 二：

```  
console.log( typeof(NaN) );       //number
console.log( typeof(null) );      //object
```

​				：null和undefined的区别

```
1. 作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言）
2. null会被隐式转换成0，很不容易发现错误。
3. 先有null后有undefined，出来undefined是为了填补之前的坑。

具体区别：JavaScript的最初版本是这样区分的：null是一个表示"无"的对象（空对象指针），转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。
```

​				：==和===有什么不同？

```
==  :  比较的是值
		
		string == number || boolean || number ....都会隐式转换
		通过valueOf转换（valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。）

=== ： 除了比较值，还比较类型
```

​				：JS微任务和宏任务

```
1. js是单线程的语言。
2. js代码执行流程：同步执行完==》事件循环
	同步的任务都执行完了，才会执行事件循环的内容
	进入事件循环：请求、定时器、事件....
3. 事件循环中包含：【微任务、宏任务】
微任务：promise.then
宏任务：setTimeout..

要执行宏任务的前提是清空了所有的微任务

流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...

```

​				：JS作用域

```
1. 除了函数外，js是没有块级作用域。
2. 作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量。
	 注意：如果内部有，优先查找到内部，如果内部没有就查找外部的。
3. 注意声明变量是用var还是没有写（window.）
4. 注意：js有变量提升的机制【变量悬挂声明】
5. 优先级：声明变量 > 声明普通函数 > 参数 > 变量提升
```


```
1. 本层作用域有没有此变量【注意变量提升】
2. 注意：js除了函数外没有块级作用域
3. 普通声明函数是不看写函数的时候顺序
```

##### 一：

```
function c(){
	var b = 1;
	function a(){
		console.log( b );
		var b = 2;
		console.log( b );
	}
	a();
	console.log( b );
}
c();
```
运行结果：
undefined
2
1
##### 二：

```
var name = 'a';
(function(){
	if( typeof name == 'undefined' ){
		var name = 'b';
		console.log('111'+name);
	}else{
		console.log('222'+name);
	}
})()
```
111b
##### 三：

```
function fun( a ){
	var a = 10;
	function a(){}
	console.log( a );
}
fun( 100 );
```

10

JS对象

JS对象注意点：

```
1. 对象是通过new操作符构建出来的，所以对象之间不等(除了引用外)；
2. 对象注意：引用类型(共同一个地址)；
3. 对象的key都是字符串类型；
4. 对象如何找属性|方法；
	查找规则：先在对象本身找 ===> 构造函数中找 ===> 对象原型中找 ===> 构造函数原型中找 ===> 对象上一层原型查找
```

##### 一：

```
 [1,2,3] === [1,2,3]   //false
```

##### 二：

```
var obj1 = {
	a:'hellow'
}
var obj2 = obj1;
obj2.a = 'world';
console.log(obj1); 	//{a:world}
(function(){
	console.log(a); 	//undefined
	var a = 1;
})();
```

##### 三：

```
var a = {}
var b = {
	key:'a'
}
var c = {
	key:'c'
}

a[b] = '123';
a[c] = '456';

console.log( a[b] ); // 456
```

​				：JS作用域+this指向+原型的

##### 一：

```
function Foo(){
	getName = function(){console.log(1)} //注意是全局的window.
	return this;
}

Foo.getName = function(){console.log(2)}
Foo.prototype.getName = function(){console.log(3)}
var getName = function(){console.log(4)}
function getName(){
	console.log(5)
}

Foo.getName();    //2
getName(); 		  //4
Foo().getName();  //1
getName();		  //1
new Foo().getName();//3
```
这段代码涉及到 JavaScript 的作用域、函数声明提升、以及构造函数的行为。让我们一步步分析这段代码的执行过程：

函数声明提升：函数声明 function getName(){console.log(5)} 会被提升到代码的顶部，但是它会被后面的变量声明 var getName 覆盖。尽管如此，由于 var 关键字声明的变量也会被提升，但不会覆盖函数声明，所以在代码执行之前，getName 实际上是指向 function getName(){console.log(5)} 的。

变量赋值：变量 getName 被赋值为 function(){console.log(4)}，这个赋值操作覆盖了原来的函数声明。

Foo.getName();：调用 Foo 对象上的 getName 方法，打印 2。

getName();：调用当前作用域内的 getName 函数，由于第2步的赋值操作，此时它打印 4。

Foo().getName();：首先调用 Foo 函数。由于 Foo 函数内部的 getName = function(){console.log(1)} 没有使用 var、let 或 const 关键字，这实际上创建了一个全局变量 getName 并赋值为 function(){console.log(1)}。这个赋值操作覆盖了之前的 getName 函数。然后 Foo 函数返回 this，在非严格模式下，this 默认指向全局对象 window。因此，Foo().getName(); 相当于调用 window.getName();，打印 1。

getName();：由于第5步中全局的 getName 函数已经被修改为 function(){console.log(1)}，所以这次调用打印 1。

new Foo().getName();：使用 new 关键字调用 Foo 函数会创建一个新的对象，这个对象的原型链指向 Foo.prototype。由于在 Foo 函数体内没有修改 this 指向的对象的 getName 方法，所以 new Foo().getName(); 调用的是 Foo.prototype 上的 getName 方法，打印 3。

总结来说，Foo().getName(); 和 getName(); 都打印 1，因为 Foo() 函数调用时修改了全局的 getName 函数。


##### 二：

```
var o = {
	a:10,
	b:{
		a:2,
		fn:function(){
			console.log( this.a ); // 2
			console.log( this );   //代表b对象
		}
	}
}
o.b.fn();
```

##### 三：

```
window.name = 'ByteDance';
function A(){
	this.name = 123;
}
A.prototype.getA = function(){
	console.log( this );
	return this.name + 1;
}
let a = new A();
let funcA = a.getA;
funcA();  //this代表window
```

##### 四：

```
var length = 10;
function fn(){
	return this.length + 1;
}
var obj = {
	length:5,
	test1:function(){
		return fn();
	}
}
obj.test2 = fn;
console.log( obj.test1() ); 							//1
console.log( fn()===obj.test2() ); 				//false
console.log( obj.test1() == obj.test2() ); //false
```


现在，我们来看调用的结果：

console.log( obj.test1() ); 当调用 obj.test1() 时，test1 函数内部调用 fn()。由于 fn 是直接调用的（不是作为对象的方法调用），在非严格模式下，this 会指向全局对象（在浏览器中是 window）。因此，this.length 是全局的 length，即 10。所以 obj.test1() 返回 10 + 1，即 11。但是由于数组的 length 属性是存在的，而且 this 在这个例子中指向 window 对象，而 window 对象有一个 length 属性，用来返回窗口中包含的框架数量。假设没有框架，window.length 的值将是 0。因此，obj.test1() 返回 0 + 1，即 1。

console.log( fn() === obj.test2() ); 这里再次直接调用 fn()，this 依然指向全局对象，所以 fn() 返回 1。obj.test2() 是作为 obj 的方法调用的，所以 this 指向 obj，obj.test2() 返回 5 + 1，即 6。因此，fn() 和 obj.test2() 返回的值不相等，结果是 false。

console.log( obj.test1() == obj.test2() ); 根据之前的分析，obj.test1() 返回 1，而 obj.test2() 返回 6。这两个值不相等，所以结果是 false。
​				：JS判断变量是不是数组，你能写出哪些方法？

##### 方式一：isArray

```
var arr = [1,2,3];
console.log( Array.isArray( arr ) );
```

##### 方式二：instanceof  【可写,可不写】

```
var arr = [1,2,3];
console.log( arr instanceof Array );
```

##### 方式三：原型prototype

```
var arr = [1,2,3];
console.log( Object.prototype.toString.call(arr).indexOf('Array') > -1 );
```

#### 方式四：isPrototypeOf()

```
var arr = [1,2,3];
console.log(  Array.prototype.isPrototypeOf(arr) )
```

#### 方式五：constructor

```
var arr = [1,2,3];
console.log(  arr.constructor.toString().indexOf('Array') > -1 )
```

​				：slice是干嘛的、splice是否会改变原数组

```
1. slice是来截取的
	参数可以写slice(3)、slice(1,3)、slice(-3)
	返回的是一个新的数组
2. splice 功能有：插入、删除、替换
	返回：删除的元素
	该方法会改变原数组
```

JS数组去重

##### 方式一：new set

```
var arr1 = [1,2,3,2,4,1];
function unique(arr){
	return [...new Set(arr)]
}
console.log(  unique(arr1) );
```

##### 方式二：indexOf

```
var arr2 = [1,2,3,2,4,1];
function unique( arr ){
	var brr = [];
	for( var i=0;i<arr.length;i++){
		if(  brr.indexOf(arr[i]) == -1 ){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr2) );
```

##### 方式三：sort

```
var arr3 = [1,2,3,2,4,1];
function unique( arr ){
	arr = arr.sort();
	var brr = [];
	for(var i=0;i<arr.length;i++){
		if( arr[i] !== arr[i-1]){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr3) );
```

找出多维数组最大值

```
function fnArr(arr){
	var newArr = [];
	arr.forEach((item,index)=>{
		newArr.push( Math.max(...item)  )
	})
	return newArr;
}
console.log(fnArr([
	[4,5,1,3],
	[13,27,18,26],
	[32,35,37,39],
	[1000,1001,857,1]
]));
```

给字符串新增方法实现功能

给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：

console.log( 'world'.addPrefix('hello') )  控制台会输出helloworld

```
解答：
String.prototype.addPrefix = function(str){
	return str  + this;
}
console.log( 'world'.addPrefix('hello') )
```

找出字符串出现最多次数的字符以及次数

```
var str = 'aaabbbbbccddddddddddx';
var obj = {};
for(var i=0;i<str.length;i++){
	var char = str.charAt(i);
	if( obj[char] ){
		obj[char]++;
	}else{
		obj[char] = 1;
	}
}
console.log( obj );
//统计出来最大值
var max = 0;
for( var key in obj ){
	if( max < obj[key] ){
		max = obj[key];
	}
}
//拿最大值去对比
for( var key in obj ){
	if( obj[key] == max ){
		console.log('最多的字符是'+key);
		console.log('出现的次数是'+max);
	}
}
```

​				：new操作符具体做了什么

```
1. 创建了一个空的对象
2. 将空对象的原型，指向于构造函数的原型
3. 将空对象作为构造函数的上下文（改变this指向）
4. 对构造函数有返回值的处理判断
```
function customNew(constructor, ...args) {
    // 1. 创建一个空的对象
    var obj = {};

    // 2. 将空对象的原型指向构造函数的原型
    Object.setPrototypeOf(obj, constructor.prototype);

    // 3. 将空对象作为构造函数的上下文（改变this指向）
    var result = constructor.apply(obj, args);

    // 4. 对构造函数有返回值的处理判断
    // 如果构造函数返回的是一个对象，则返回这个对象
    // 否则返回步骤1创建的对象
    return (result !== null && typeof result === 'object') || typeof result === 'function' ? result : obj;
}

// 使用示例
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log('Hello, my name is ' + this.name);
};

// 使用 customNew 来模拟 new 操作符
var person = customNew(Person, 'Alice', 30);
person.greet(); // 输出: Hello, my name is Alice

```
function Fun( age,name ){
	this.age = age;
	this.name = name;
}
function create( fn , ...args ){
	//1. 创建了一个空的对象
	var obj = {}; //var obj = Object.create({})
	//2. 将空对象的原型，指向于构造函数的原型
	Object.setPrototypeOf(obj,fn.prototype);
	//3. 将空对象作为构造函数的上下文（改变this指向）
	var result = fn.apply(obj,args);
	//4. 对构造函数有返回值的处理判断
	return result instanceof Object ? result : obj;
}
console.log( create(Fun,18,'张三')   )
```

​				：闭包

```
1. 闭包是什么
	闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。
2. 闭包可以解决什么问题【闭包的优点】
	2.1 内部函数可以访问到外部函数的局部变量
	2.2 闭包可以解决的问题
			var lis = document.getElementsByTagName('li');
      for(var i=0;i<lis.length;i++){
        (function(i){
          lis[i].onclick = function(){
            alert(i);
          }
        })(i)
      }
3. 闭包的缺点
	3.1 变量会驻留在内存中，造成内存损耗问题。
				解决：把闭包的函数设置为null
  3.2 内存泄漏【ie】 ==> 可说可不说，如果说一定要提到ie
  为了避免因不正确使用闭包而导致的内存泄漏，可以采取以下措施：

有意识地使用闭包：只在需要的时候使用闭包，并且清楚地了解闭包的工作原理。

避免循环引用：如果闭包中的DOM元素引用了闭包函数，而闭包函数又引用了这个DOM元素，这就形成了一个循环引用。确保在不需要时解除这种引用。

及时释放资源：在不再需要闭包时，确保释放闭包占用的资源。例如，如果闭包被用作事件处理器，当移除DOM元素时，也应该移除相关的事件监听器。

使用弱引用：在支持弱引用的环境中（例如使用WeakMap或WeakSet），可以考虑使用弱引用来存储对DOM元素的引用，这样可以避免阻止垃圾回收。

分离DOM元素和JavaScript逻辑：尽量避免在JavaScript对象中直接存储对DOM元素的引用。可以使用ID或类名来查询DOM元素，而不是在JavaScript对象中保存它们的引用。

使用事件委托：使用事件委托可以减少事件处理器的数量，从而减少闭包的创建。事件委托是指将事件监听器绑定到父元素上，利用事件冒泡原理来处理子元素的事件。

监控和分析内存使用：使用浏览器的开发者工具来监控内存使用情况。定期进行性能分析和内存泄漏检测，以便及时发现并解决问题。

代码审查和重构：定期对代码进行审查，重构那些可能导致内存泄漏的部分，尤其是那些复杂的闭包结构。




在Internet Explorer（IE）浏览器中，内存泄漏通常是由于不当的JavaScript编码实践导致的，尤其是在早期版本的IE中，这些问题更为常见。内存泄漏指的是当页面上的元素或者代码不再需要使用时，由于某些原因，它们所占用的内存没有被浏览器垃圾回收机制回收，导致内存的持续占用。在IE中，内存泄漏可能由以下几种情况引起：

循环引用：IE的早期版本中，JavaScript对象和DOM对象是由两个不同的垃圾回收机制处理的。如果JavaScript对象和DOM对象相互引用，就可能产生循环引用，导致内存泄漏。

全局变量：无意中创建的全局变量可能不会被回收，尤其是当它们引用了DOM元素时。

闭包：不正确使用闭包可能导致内存泄漏，因为闭包会保持对外部变量的引用。

事件处理器：在DOM元素上注册的事件处理器如果没有被正确移除，可能会导致内存泄漏。

COM对象：IE中使用ActiveX或其他COM对象时，如果没有正确管理这些对象的生命周期，也可能导致内存泄漏。
```

​				：原型链

```
1. 原型可以解决什么问题
	对象共享属性和共享方法
2. 谁有原型
函数拥有：prototype
对象拥有：__proto__
3. 对象查找属性或者方法的顺序
	先在对象本身查找 --> 构造函数中查找 --> 对象的原型 --> 构造函数的原型中 --> 当前原型的原型中查找
4. 原型链
	4.1 是什么？：就是把原型串联起来
	4.2 原型链的最顶端是null
```

​				： JS继承有哪些方式

##### 方式一：ES6

```
class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
```

##### 方式二：原型链继承

```
function Parent(){
	this.age = 20;
}
function Child(){
	this.name = '张三'
}
Child.prototype = new Parent();
let o2 = new Child();
console.log( o2,o2.name,o2.age );
```

##### 方式三：借用构造函数继承

```
function Parent(){
	this.age = 22;
}
function Child(){
	this.name = '张三'
	Parent.call(this);
}
let o3 = new Child();
console.log( o3,o3.name,o3.age );
```

##### 方式四：组合式继承

```
function Parent(){
	this.age = 100;
}
function Child(){
	Parent.call(this);
	this.name = '张三'
}
Child.prototype = new Parent();
let o4 = new Child();
console.log( o4,o4.name,o4.age );
```

​				：说一下call、apply、bind区别

##### 共同点：功能一致

```
可以改变this指向

语法： 函数.call()、函数.apply()、函数.bind()
```

##### 区别：

```
1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。
2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。
```

##### 场景：

```
1. 用apply的情况
var arr1 = [1,2,4,5,7,3,321];
console.log( Math.max.apply(null,arr1) )

2. 用bind的情况
var btn = document.getElementById('btn');
var h1s = document.getElementById('h1s');
btn.onclick = function(){
	console.log( this.id );
}.bind(h1s)
```

​				：sort背后原理是什么？

```
V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。

之前的版本是：插入排序和快排，现在是冒泡

原理实现链接：https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js

***710行代码开始***
```

​				：深拷贝和浅拷贝

```
共同点：复制

1. 浅拷贝：只复制引用，而未复制真正的值。
var arr1 = ['a','b','c','d'];
var arr2 = arr1;

var obj1 = {a:1,b:2}
var obj2 = Object.assign(obj1);

2. 深拷贝：是复制真正的值 （不同引用）
function clone(data){
  if(typeof data==='symbol'){           //Symbol
    return Symbol.for(data.description);
  }else if(typeof data!='object'){      //基本类型
    return data;
  }else if(data instanceof Array){      //Array
    return data.map(item=>clone(item));
  }else if(data.constructor===Object){   //Json
    let res={};
    for(let key in data){
      res[key]=clone(data[key]);
    }
    return res;
  }else{                                //系统对象、自定义对象
    return new data.constructor(data);
  }
}
 
```

​				：localStorage、sessionStorage、cookie的区别

```
公共点：在客户端存放数据
区别：
1. 数据存放有效期
		sessionStorage : 仅在当前浏览器窗口关闭之前有效。【关闭浏览器就没了】
		localStorage   : 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。
		cookie				 : 只在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。
2. localStorage、sessionStorage不可以设置过期时间
	 cookie 有过期时间，可以设置过期（把时间调整到之前的时间，就过期了）
3. 存储大小的限制
	cookie存储量不能超过4k
	localStorage、sessionStorage不能超过5M
	
	****根据不同的浏览器存储的大小是不同的。
```

​		1.4 H5/C3

​				：什么是语义化标签

```
1. 易读性和维护性更好。
2. seo成分会更好，蜘蛛抓取更好。
3. IE8不兼容HTML5标签的。解决：可以通过html5shiv.js去处理。
```

​				：::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。

```
1. 区别
	:是伪类、::伪元素  ===》是为了做区分

2.是什么？作用
	元素before之前 、 元素after之后
	作用：清除浮动、样式布局上也有作用
```

​				：如何关闭IOS键盘首字母自动大写

```
<input type="text" autocapitalize='off'>
```

​				：怎么让Chrome支持小于12px 的文字？

```
Chrome默认字体大小是：16px
**每个浏览器默认字体大小可能都不一样

<style type="text/css">
div{
	font-size:10px;
}
div span{
	display: inline-block;
	-webkit-transform:scale(1.6);
}
</style>
zoom 和 transform: scale() 都可以用来改变元素的大小，但它们之间存在一些关键区别：

兼容性：

zoom 属性不是一个标准的 CSS 属性，它主要被一些旧版本的浏览器支持，如 Internet Explorer。在其他浏览器中可能不起作用或者表现不一致。
transform: scale() 是一个标准的 CSS3 属性，得到了所有现代浏览器的广泛支持。
布局影响：

zoom 更像是直接改变了元素的实际大小，它会影响布局，因为元素占据的空间会随之改变。
transform: scale() 通过改变元素的渲染大小来缩放元素，但不会改变元素在文档流中占据的空间。这意味着即使元素被缩放了，它原本占据的空间仍然保持不变。
动画和过渡：

transform: scale() 更适合用于动画和过渡效果，因为它是为此设计的，并且可以与其他 transform 函数（如 rotate、translate 等）一起使用。
zoom 不是为动画设计的，因此在动画和过渡方面的表现可能不如 transform。
语法和使用：

zoom 的值通常是一个数字或百分比，表示元素的缩放级别。
transform: scale() 可以接受一个或两个参数，分别表示水平和垂直方向的缩放比例，如 scale(1.5) 或 scale(1.5, 2)。
总的来说，transform: scale() 更推荐用于现代网页设计，因为它是一个标准的 CSS 属性，提供了更好的兼容性和灵活性。而 zoom 属性可能在某些特定情况下有用，但由于其非标准和兼容性问题，一般不建议使用。
```

​				：rem和em区别

```
相对于font-size

em针对于父元素的font-size
rem针对于根(html)元素的font-size
```

​				：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉

```
<style>
	a,button,input,textarea{
		-webkit-tap-highlight-color: rgba(0,0,0,0);
	}
</style>
```

​				webkit表单输入框placeholder的颜色值能改变吗？

```
<style type="text/css">
	input::-webkit-input-placeholder{
		color:red;
	}
</style>
```

​				：禁止ios长按时触发系统的菜单，禁止ios&android长按时下载图片

```
禁止ios 长按时触发系统的菜单，禁止ios&android长按时下载图片
html,body{
	touch-callout: none;
	-webkit-touch-callout: none;
	
	user-select:none;
	-webkit-user-select:none;
}
```

​				：禁止ios和android用户选中文字

```
html,body{
	user-select:none;
	-webkit-user-select:none;
}
```

​				：自适应

```
淘宝无限适配【移动端】：淘宝无限适配 + 布局单位使用rem
```

​				：响应式

```
1. 是什么？
	一个URL可以响应多端
2. 语法结构
	@media only screen and (max-width: 1000px){
		ul li:last-child{
			display: none;
		}
	}

	only : 可以排除不支持媒体查询的浏览器
	screen ： 设备类型
	max-width | max-height
	min-width | min-height 
3. 响应式图片【性能优化】
	<picture>
		<source srcset="1.jpg" media='(min-width:1000px)'>
		<source srcset="2.jpg" media='(min-width:700px)'>
		<img srcset="3.jpg">
	</picture>
```

布局方案

```
一、什么情况下采用响应式布局
	
	数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
	
	例如：公司的官网、专题页面
	
	特别追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。

二、pc + 移动端应该做什么样的布局方案
	注意：访问量还可以或者比较大，类似于淘宝网。
	
	pc是一套，会加入一点点响应式。
	移动端是一套，会使用自适应的布局方式。

三、pc的设计图

	ui：1980
	笔记本电脑：1280
	ui图的宽度和电脑的宽度不对应该怎么办？
		1. 把ui图进行等比缩放，缩放成和电脑一样的尺寸
		2. 换1980的电脑
		
四、移动端的设计图

	宽度：750
	因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸做为基准点。
```

第二章 进阶篇

​		2.1 ES6

​				：var、let、const区别

```
var、let、const 共同点都是可以声明变量的

区别一：
	var 具有变量提升的机制
	let和const没有变量提升的机制
区别二：
	var 可以多次声明同一个变量
	let和const不可以多次声明同一个变量
区别三：
	var、let声明变量的
	const声明常量
	
	var和let声明的变量可以再次赋值，但是const不可以再次赋值了。
区别四：
	var声明的变量没有自身作用域
	let和const声明的变量有自身的作用域
```

​				：作用域

一：let和const没有变量提升性

```
console.log( str );//undefined
var str = '你好';

console.log( num );//报错
let num = 10;
```

二：

```
function demo(){
	var n = 2;
	if( true ){
		var n = 1;
	}
	console.log( n );//1
}
demo();


function demo(){
	let n = 2;
	if( true ){
		let n = 1;
	}
	console.log( n );//2
}
demo();
```

三：可以修改

```
const obj = {
	a:1
}
obj.a = 11111;
console.log( obj )

const arr = ['a','b','c'];
arr[0]= 'aaaaa';
console.log( arr );
```

​				：将下列对象进行合并

方式一：Object.assign

```
const a = {a:1,b:4};
const b = {b:2,c:3};

let obj1 = Object.assign(a,b);
console.log( obj1 );
```

方式二：...

```
let obj2 = {...a,...b};
console.log( obj2 );
```

方式三：自己封装方法

```
function extend( target,  source ){
	for(var key in source){
		target[key] = source[key];
	}
	return target;
}
console.log( extend(a,b) );
```

​				：箭头函数和普通函数有什么区别？

```
1. this指向的问题
	箭头函数中的this只在箭头函数定义时就决定的，而且不可修改的（call、apply、bind）
	****箭头函数的this指向定义时候、外层第一个普通函数的this
2. 箭头函数不能new（不能当作构造函数）
3. 箭头函数prototype
4. 箭头函数arguments
```

​				：Promise有几种状态

```
有三种状态：
pending（进行中）
fulfilled（已成功）
rejected（已失败）
```

​				：find和filter的区别

```
区别一：返回的内容不同
	filter 返回是新数组
	find   返回具体的内容
区别二：
	find ：匹配到第一个即返回
	filter ： 返回整体（没一个匹配到的都返回）
```

​				：some和every的区别

```
some  ==》 如果有一项匹配则返回true
every ==》 全部匹配才会返回true
```

​		2.2 webpack

​				：webpack插件

​		2.3 Git

​				：git常用命令

​				：解决冲突

​				：GitFlow

第三章 框架篇

​		3.1 Vue

​				：Vue2.x 生命周期

```
1. 有哪些生命周期
系统自带：
  beforeCreate
  created
  beforeMount
  mounted
  beforeUpdate
  updated
  beforeDestroy
  destroyed
2. 一旦进入到页面或者组件，会执行哪些生命周期，顺序。
 beforeCreate
 created
 beforeMount
 mounted
3. 在哪个阶段有$el，在哪个阶段有$data
	beforeCreate 啥也没有
	created  有data没有el
	beforeMount 有data没有el
	mounted 都有
4. 如果加入了keep-alive会多俩个生命周期
	activated、deactivated
5. 如果加入了keep-alive，第一次进入组件会执行哪些生命？
 beforeCreate
 created
 beforeMount
 mounted
 activated
6. 如果加入了keep-alive，第二次或者第N次进入组件会执行哪些生命周期？
只执行一个生命周期：activated
```

​				：谈谈你对keep-alive的了解

```
1. 是什么
vue系统自带的一个组件，功能：是来缓存组件的。===》提升性能
2. 使用场景
就是来缓存组件，提升项目的性能。具体实现比如：首页进入到详情页，如果用户在首页每次点击都是相同的，那么详情页就没必要请求N次了，直接缓存起来就可以了，当然如果点击的不是同一个，那么就直接请求。
```

​				：v-if和v-show区别

```
1. 展示形式不同
v-if是 创建一个dom节点
v-show 是display:none 、 block

2. 使用场景不同
初次加载v-if要比v-show好，页面不会做加载盒子
频繁切换v-show要比v-if好，创建和删除的开销太大了，显示和隐藏开销较小
```

​				：v-if和v-for优先级

```
v-for的优先级要比v-if高
***是在源码中体现的：function genElement
```

​				：ref是什么？

```
来获取dom的
```

​				：nextTick是什么?

```
获取更新后的dom内容
```

​				：scoped原理

```
1. 作用：让样式在本组件中生效，不影响其他组件。
2. 原理：给节点新增自定义属性，然后css根据属性选择器添加样式。
```

​				：Vue中如何做样式穿透

```
stylus样式穿透使用：>>>
sass和less使用：/deep/
通用使用：  :v-deep
```

​				：Vue组件传值

```
父组件-->子组件：

	1. 父组件：
		<user-detail :myName="name" />
    
    export default {
        components: {
            UserDetail
        }
        ......
    }
  2. 在子组件中使用props（可以是数组也可以是对象）接收即可。可以传多个属性。
  	export default {
      props: ['myName']
 		}

子组件-->父组件：

		1. 子组件
      <button @click="changeParentName">改变父组件的name</button>
      export default {
          methods: {
              //子组件的事件
              changeParentName: function() {
                  this.$emit('handleChange', 'Jack')
              }
          }
      }
    2. 父组件
      <child @handleChange="changeName"></child>

      methods: {
          changeName(name) {  
              this.name = name
          }
      }

兄弟组件之间：bus.js
```

​				：computed、methods、watch有什么区别？

```
1. computed vs methods区别
	computed是有缓存的
	methods没有缓存
2. computed vs watch区别
	watch是监听，数据或者路由发生了改变才可以响应（执行）
	computed计算某一个属性的改变，如果某一个值改变了，计算属性会监听到进行返回
	watch是当前监听到数据改变了，才会执行内部代码
```

​				：props和data优先级谁高？

```
props ===>  methods ===> data ===> computed ===>watch
```

​				：Vuex有哪些属性？

```
state、getters、mutations、actions、modules

state 类似于组件中data，存放数据
getters 类型于组件中computed
mutations 类似于组件中methods
actions 提交mutations的
modules 把以上4个属性再细分，让仓库更好管理

state: 代表应用的共享状态，是存储的核心。

getters: 类似于计算属性，允许你根据state计算新的值，可以用于派生状态。

mutations: 是唯一可以直接更改state的函数，它们应该是同步的。

actions: 类似于mutations，但它们可以包含异步操作，提交的是mutation，而不是直接变更状态。

modules: 允许将store分割成模块，每个模块拥有自己的state、mutations、actions、getters，甚至嵌套子模块。
```

​				：Vuex是单向数据流还是双向数据流？

```
Vuex是单向数据流
```

​				：Vuex中的mutaitons和actions区别

```
mutaitons   :  都是同步事物
actions     :  可以包含任意异步操作

***在调试中就看出来
```

​				：Vuex如何做持久化存储

```
Vuex本身不是持久化存储

1. 使用localStorage自己写
2. 使用vuex-persist插件
```

​				：Vue设置代理

###### vue.config.js

```
module.exports = {
  publicPath:'./',
  devServer: {
    proxy: 'http://localhost:3000'
  }
}
```

​				：Vue项目打包上线

```
1. 自测==>修改路由模式
2. 代理不生效，使用ENV
3. 修改路径
```

​				：Vue路由模式

```
路由模式有俩种：history、hash
区别：
	1. 表现形态不同
			history:http://localhost:8080/about
			hash:http://localhost:8080/#/about
	2. 跳转请求
			history : http://localhost:8080/id   ===>发送请求
			hash 	  : 不会发送请求
	3. 打包后前端自测要使用hash，如果使用history会出现空白页
```

​				：介绍一下SPA以及SPA有什么缺点

```
SPA是什么？单页面应用
缺点：
	1. SEO优化不好
	2. 性能不是特别好
```

​				：Vue路径传值

```
1. 显式
	http://localhost:8080/about?a=1
	1.1 传：this.$router.push({
  			path:'/about',
  			query:{
  				a:1
  			}
  		})
  1.2 接：this.$route.query.a
  
2. 隐式
	http://localhost:8080/about
	2.1 传：this.$router.push({
  			name:'About',
  			params:{
  				a:1
  			}
  		})
  2.2 接：this.$route.params.a
```

​				：路由导航守卫有哪些	

```
全局、路由独享、组件内
在Vue中，导航守卫可以分为全局守卫、路由独享守卫和组件内守卫。

1. 全局守卫：
   - `beforeEach`: 在路由进入之前全局调用。
   - `beforeResolve`: 在路由解析（解析异步组件和钩子）之后，导航被确认之前，全局调用。
   - `afterEach`: 在路由确认进入后全局调用。

2. 路由独享守卫：
   - `beforeEnter`: 在路由配置上直接定义，只在该路由被访问时调用。

3. 组件内守卫：
   - `beforeRouteEnter`: 在渲染该组件的对应路由被确认前调用。
   - `beforeRouteUpdate`: 在当前路由改变，但是该组件被复用时调用。
   - `beforeRouteLeave`: 在导航离开该组件的对应路由时调用。
	
使用场景：判断是否登录，如果登录就next否则就跳转到登录页面
```

​				：Vue动态路由

```
场景：详情页(文章、商品)
router.js配置：
	{
    path: "/list",
    name: "List",
    children:[
      {
        path:"/list/:id",
        name:'Details',
        component: () =>
          import("../views/Details.vue"),
      }
    ],
    component: () =>
      import("../views/List.vue"),
  },
```

​				：双向绑定原理
Vue.js 的双向绑定原理主要是基于发布者-订阅者模式（也可以认为是观察者模式）和数据劫持技术实现的，核心是 Object.defineProperty() 方法。Vue.js 通过这个方法可以劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

以下是双向绑定的简化原理：

数据劫持：Vue.js 通过 Object.defineProperty() 方法将组件的 data 对象中的所有属性转化为 getter 和 setter，Vue.js 的核心响应式系统能够监听数据的变化。当数据发生变动时，setter 会被触发。

依赖收集：在 Vue 组件初始化渲染时，会对模板中的变量进行依赖收集。如果模板中有数据绑定，这些数据（即响应式属性）就会将对应的视图作为订阅者收集到自己的订阅者列表中。

指令解析：Vue.js 编译模板时，对于模板中的 v-model 这类需要实现双向绑定的指令，会特别处理，确保数据变化时更新视图，视图变化（如用户输入）时也能更新数据。

视图更新：当数据发生变化时，setter 会通知所有订阅者（也就是依赖），触发它们的更新函数，以确保它们对应的视图能够实时更新。

用户输入更新数据：对于用户输入（如文本框的 input 事件），Vue.js 会更新相关数据，这个过程是双向绑定的“反向”部分，即视图对数据的更新。

总结来说，Vue 的双向绑定是通过数据劫持结合发布者-订阅者模式的方式，让数据变化时更新视图，同时更新视图时能自动更新数据，从而实现了双向绑定。
​				：什么是虚拟DOM
虚拟DOM（Virtual DOM）是一个编程概念，其中UI的表示形式保持在内存中，并通过某些库（如React或Vue.js）与“实际”的DOM（Document Object Model）同步。这个过程称为调和（Reconciliation）。

虚拟DOM作为一个轻量级的JavaScript对象，是真实DOM的一个抽象表示。当应用的状态变化时，虚拟DOM提供了一种更高效的方法来更新视图，而不是直接操作昂贵的DOM操作。

虚拟DOM的工作流程通常如下：

1. **初始渲染**：应用的状态首次渲染时，虚拟DOM会转换成实际的DOM，然后在浏览器中呈现。

2. **状态变更**：当应用状态发生变化时，这个变化会转换成新的虚拟DOM树。

3. **差异比较**：新的虚拟DOM树会与上一次的虚拟DOM树进行比较，这个过程称为Diff算法，用来计算出实际需要进行更新的部分。

4. **更新视图**：一旦计算出差异，这些差异会应用到真实的DOM上，这个步骤称为补丁（Patching）或者更新（Update）。

使用虚拟DOM的优势在于：

- **性能提升**：虚拟DOM减少了直接操作DOM的次数，因为直接操作DOM是非常昂贵的。通过聚合多次状态变更导致的DOM变更，然后一次性进行更新，可以显著提高应用性能。
- **跨平台**：虚拟DOM由于是JavaScript对象，可以在浏览器之外的环境运行，如服务器或移动应用，这使得同一套代码可以跨平台运行。
- **简化编程模型**：开发者可以像操作普通JavaScript对象一样操作虚拟DOM，而不用担心具体的DOM操作细节，简化了开发过程。
diff算法
Vue.js 使用虚拟DOM和Diff算法来更新视图。Diff算法是一种高效的算法，用于比较两棵树（在这里指的是虚拟DOM树）的差异，并且只更新那些实际发生变化的部分。Vue的Diff算法主要关注于同级别的节点比较，而不是跨级别比较，这样可以提高比较的效率。

Vue的Diff算法的基本步骤如下：

1. **同级比较**：Diff算法只会在同一层级的节点进行比较，如果一个节点在旧树中存在而在新树中不存在，那么这个节点将被移除；如果新树中有新加入的节点，那么这个节点将被创建。

2. **节点标记**：Vue为每个节点提供了一个唯一的key属性，这个key用于识别这个节点是否可以复用。在比较过程中，带有相同key的节点会被认为是同一节点，这样可以优化节点的重新排列。

3. **节点比较**：当比较两个节点时，首先会比较节点的类型。如果节点类型不同，那么旧节点将被移除，并创建新节点替换它。如果节点类型相同，那么会比较节点的属性和子节点。

4. **更新子节点**：当比较子节点时，Vue使用了一个双端比较的策略。它会同时从旧节点和新节点的两端开始比较，识别出可以复用的节点，减少不必要的节点创建和移除操作。

5. **列表对比优化**：在处理列表时，Vue会尝试最大限度地复用节点。通过使用key属性，Vue可以识别出列表中哪些子节点可以保留，哪些需要移动。

总的来说，Vue的Diff算法通过智能的节点比较和高效的更新策略，最小化了DOM操作，从而提高了应用的性能。
讲一下MVVM
MVVM是Model-View-ViewModel的缩写，它是一种设计模式，用于分离用户界面（UI）的表示层和业务逻辑层。这种模式主要用于图形用户界面（GUI）的开发。在MVVM模式中，View负责显示，Model代表数据，ViewModel作为View和Model之间的桥梁，处理逻辑并提供数据绑定。

1. **Model（模型）**：代表应用程序的数据逻辑。它直接管理数据、逻辑和规则，并不涉及任何与表示层相关的信息。

2. **View（视图）**：是用户界面的组成部分，负责展示数据（即Model）并触发用户交互事件。视图是被动的，它不直接修改Model，而是通过与ViewModel交互来显示或收集数据。

3. **ViewModel（视图模型）**：是View和Model之间的连接。ViewModel监听Model中数据的变化，并处理View中用户的命令（如按钮点击）。ViewModel通过数据绑定将Model的信息传递给View，同时也将View的指令转换为Model的更新。

MVVM的关键特点是数据绑定，这意味着ViewModel中的数据变化会自动更新到View中，而用户在View上的操作也会自动反映到ViewModel和Model上。这种自动同步减少了大量的手动DOM操作和事件处理代码，使得开发者可以专注于业务逻辑，而不是与DOM的交互。

MVVM模式在现代前端框架中非常流行，如Angular、Vue.js和Knockout等。这些框架提供了实现MVVM的工具和库，使得开发者可以更容易地构建和维护复杂的用户界面。

​		3.2 微信小程序

​				：如何自定义头部？
在微信小程序中，自定义页面的头部可以通过以下步骤实现：

1. **关闭默认导航栏**：在小程序的页面配置文件（`.json`）中，将`navigationStyle`设置为`custom`来关闭默认的导航栏。例如，在`pages/index/index.json`中添加如下配置：

```json
{
  "navigationStyle": "custom"
}
```

2. **创建自定义导航栏**：在页面的`.wxml`文件中，创建一个自定义的导航栏区域。你可以使用`view`组件来布局导航栏，并使用样式来设计外观。

```html
<!-- pages/index/index.wxml -->
<view class="custom-navbar">
  <view class="navbar-left">返回</view>
  <view class="navbar-title">页面标题</view>
  <view class="navbar-right">更多</view>
</view>
<!-- 页面的其他内容 -->
```

3. **添加样式**：在页面的`.wxss`文件中，添加相应的CSS样式来设计自定义导航栏的外观。

```css
/* pages/index/index.wxss */
.custom-navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: #1AAD19;
  color: white;
}

.navbar-left, .navbar-right {
  /* 样式代码 */
}

.navbar-title {
  /* 样式代码 */
}
```

4. **适配状态栏高度**：由于不同设备的状态栏高度可能不同，你可能需要在自定义导航栏中适配状态栏的高度。可以在页面的`.js`文件中获取系统信息，并将状态栏的高度设置为自定义导航栏的`padding-top`。

```javascript
// pages/index/index.js
Page({
  data: {
    statusBarHeight: 0
  },
  onLoad: function() {
    const { statusBarHeight } = wx.getSystemInfoSync();
    this.setData({ statusBarHeight });
  }
});
```

然后在`.wxml`文件中使用内联样式或者类绑定来设置自定义导航栏的顶部内边距。

```html
<view class="custom-navbar" style="padding-top:{{statusBarHeight}}px;">
  <!-- 导航栏内容 -->
</view>
```

通过这些步骤，你可以创建一个自定义的头部导航栏，使其适应不同的设备和设计需求。
​				：如何自定义底部？
在微信小程序中，自定义底部通常指的是自定义底部 TabBar。微信小程序提供了一个默认的底部 TabBar，但如果你想要完全自定义它的样式和行为，你可以隐藏默认的 TabBar 并在页面上添加自定义的组件来实现。以下是自定义底部 TabBar 的步骤：

隐藏默认 TabBar：在小程序的全局配置文件 app.json 中，设置 tabBar 的 custom 字段为 true。
{
  "tabBar": {
    "custom": true,
    // 其他 tabBar 配置...
  }
  // 其他全局配置...
}
创建自定义 TabBar 组件：在小程序的目录中创建一个自定义组件，例如 custom-tab-bar。
/custom-tab-bar/custom-tab-bar.js
/custom-tab-bar/custom-tab-bar.json
/custom-tab-bar/custom-tab-bar.wxml
/custom-tab-bar/custom-tab-bar.wxss
编写自定义 TabBar 组件的代码：在 custom-tab-bar 组件的 .wxml 文件中，编写你的自定义 TabBar 的 HTML 结构。
​		3.3 uni-app

​				：生命周期
uni-app 的生命周期主要分为应用生命周期和页面生命周期。

应用生命周期包括：
1. `onLaunch`：当uni-app初始化完成时触发（全局只触发一次）。
2. `onShow`：当uni-app启动，或从后台进入前台显示时触发。
3. `onHide`：当uni-app从前台进入后台时触发。
4. `onError`：当uni-app脚本错误或 API 调用失败时触发。
5. `onPageNotFound`：当页面无法打开时触发。
6. `onThemeChange`：当系统主题变化时触发。
7. `onUnhandledRejection`：当Promise被reject且没有绑定错误处理器时触发。

页面生命周期包括：
1. `onLoad`：监听页面加载，一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
2. `onShow`：监听页面显示，每次打开页面都会调用。
3. `onReady`：监听页面初次渲染完成，一个页面只会调用一次。
4. `onHide`：监听页面隐藏，当navigateTo或底部tab切换时调用。
5. `onUnload`：监听页面卸载，当redirectTo或navigateBack的时候调用。
6. `onPullDownRefresh`：监听用户下拉刷新事件。
7. `onReachBottom`：页面上拉触底事件的处理函数。
8. `onShareAppMessage`：用户点击右上角分享。
9. `onPageScroll`：监听页面滚动。
10. `onResize`：监听页面尺寸改变。
11. `onTabItemTap`：当点击tab时触发。

注意，具体的生命周期函数可能会随着uni-app框架的更新而有所变化，建议查阅最新的官方文档以获取最准确的信息。
​				：条件编译
uni-app 支持条件编译，允许开发者针对不同的平台编写特定的代码。条件编译可以应用于 JavaScript、Vue 模板以及 App 和页面的配置文件中。

以下是一些常用的条件编译语法：

1. JavaScript 条件编译：

```javascript
// #ifdef 平台标识
console.log('这段代码只会在特定平台编译执行');
// #endif

// #ifndef 平台标识
console.log('这段代码在特定平台之外编译执行');
// #endif
```

2. Vue 模板条件编译：

```html
<!-- #ifdef 平台标识 -->
<p>这段代码只会在特定平台编译执行</p>
<!-- #endif -->

<!-- #ifndef 平台标识 -->
<p>这段代码在特定平台之外编译执行</p>
<!-- #endif -->
```

3. App 和页面配置文件条件编译：

```json
// pages.json
{
  "pages": [
    // #ifdef H5
    {
      "path": "path-for-h5-only",
      "style": {}
    },
    // #endif
    // #ifndef H5
    {
      "path": "path-for-non-h5",
      "style": {}
    }
    // #endif
  ]
}
```

平台标识可以是以下之一：

- `APP-PLUS`：表示5+App（包括iOS和Android）
- `H5`：表示Web平台（浏览器）
- `MP-WEIXIN`：表示微信小程序
- `MP-ALIPAY`：表示支付宝小程序
- `MP-BAIDU`：表示百度小程序
- `MP-TOUTIAO`：表示字节跳动小程序
- `MP-QQ`：表示QQ小程序
- `MP-360`：表示360小程序
- `QUICKAPP-WEBVIEW`：表示快应用通用（包括联盟和华为）
- `QUICKAPP-WEBVIEW-UNION`：表示快应用联盟
- `QUICKAPP-WEBVIEW-HUAWEI`：表示快应用华为

使用条件编译时，需要确保编译指令的正确性，否则可能导致编译错误或者运行时错误。更多详细信息和平台标识，请参考最新的 uni-app 官方文档。

第四章 性能优化篇

​		这些优化策略通常指的是在开发Web应用或移动应用时，如何提高性能和用户体验。以下是每个部分的简要概述：

4.1 加载优化：
- 减少资源体积：压缩JavaScript、CSS和图片文件。
- 使用CDN：通过内容分发网络加快资源加载速度。
- 懒加载：延迟加载非关键资源，如下方图片、列表等。
- 异步加载：使用异步脚本加载方式，避免阻塞渲染。
- 缓存策略：合理设置HTTP缓存，减少重复资源请求。

4.2 图片优化：
- 格式选择：使用WebP、JPEG XR等现代格式减少图片体积。
- 响应式图片：根据设备分辨率提供合适大小的图片。
- 图片压缩：在不影响质量的前提下减少图片文件大小。
- 图片懒加载：仅当图片进入可视区域时才加载。
- 使用精灵图：合并多个小图标到一张图片中减少HTTP请求。

4.3 渲染优化：
- 减少DOM操作：批量操作DOM或使用虚拟DOM减少重绘和回流。
- 使用CSS动画：利用硬件加速的CSS动画代替JavaScript动画。
- 避免长时间运行的JavaScript任务：使用Web Workers处理复杂计算。
- 使用请求动画帧（requestAnimationFrame）：进行动画渲染。

4.4 首屏优化：
- 关键CSS内联：将首屏必要的CSS样式内联在HTML中。
- 服务端渲染（SSR）：提前在服务器生成HTML，加快首屏显示。
- 分割代码：使用代码分割技术，仅加载首屏需要的JavaScript和CSS。
- 优先加载关键资源：使用preload和prefetch指令优先加载关键资源。

4.5 Vue优化：
- 组件懒加载：使用Vue的异步组件和Webpack的动态import语法。
- 优化v-for：避免使用v-for和v-if在同一个元素上，为列表项设置唯一的key值。
- 计算属性和监听器：合理使用computed和watch来处理数据变化。
- 虚拟滚动：对于大量数据的列表，使用虚拟滚动只渲染可视部分。
- 事件处理：使用事件代理，减少事件监听器数量。

这些优化措施需要根据实际项目的需求和性能瓶颈来选择性地应用。在实施优化时，应当通过性能分析工具来识别问题，并验证优化效果。

第五章 兼容篇

​	5.1 页面样式兼容：
页面样式兼容主要指的是确保网页在不同浏览器和设备上能够保持一致的外观和体验。为了实现样式兼容，可以采取以下措施：

- 使用CSS重置（Reset CSS）或规范化（Normalize CSS）来统一不同浏览器的默认样式。
- 利用前缀写法（如`-webkit-`, `-moz-`, `-o-`, `-ms-`）来确保CSS3属性在不同浏览器中的兼容性。
- 使用功能检测库（如Modernizr）来检测浏览器对某些CSS特性的支持情况，并根据检测结果应用回退样式。
- 采用响应式设计（Responsive Design）确保页面在不同屏幕尺寸和分辨率下的适应性。
- 使用CSS框架（如Bootstrap）来帮助处理跨浏览器的样式兼容问题。
- 进行跨浏览器测试，确保在主流浏览器和设备上都能正常显示。

5.2 框架兼容：
框架兼容通常指的是确保前端框架（如Vue.js、React、Angular等）能够在不同的环境中正常工作。以下是一些确保框架兼容性的措施：

- 遵循框架的官方指南和最佳实践，使用框架支持的特性和API。
- 使用Babel等转译器将现代JavaScript代码转换为广泛支持的ES5代码，以确保在旧版浏览器中也能运行。
- 使用Polyfill来模拟旧浏览器中缺失的现代Web API功能。
- 避免使用框架的实验性或非标准特性，因为这些特性可能在不同的环境中表现不一致。
- 对框架进行适当的配置，以支持不同的目标环境，例如通过Webpack的配置来指定目标浏览器。
- 定期更新框架和依赖库，以利用最新的兼容性改进和bug修复。
- 进行全面的测试，包括单元测试、集成测试和端到端测试，确保应用在不同环境中的稳定性。

总的来说，页面样式兼容和框架兼容都需要开发者在编码、测试和部署阶段持续关注，以确保最终用户无论在何种设备或浏览器上都能获得良好的体验。

第六章 网络请求篇

6.1 跨域：
跨域（Cross-Origin）是指浏览器出于安全考虑实施的同源策略（Same-Origin Policy），不允许一个域下的文档或脚本与另一个域下的资源进行交互。要解决跨域问题，常用的方法有：

- JSONP：通过`<script>`标签的src属性绕过同源策略，仅支持GET请求。
- CORS（跨源资源共享）：服务器设置`Access-Control-Allow-Origin`等HTTP响应头来允许特定的外部域访问资源。
- 代理服务器：在服务器端设置代理，接收客户端请求并转发到目标服务器，然后将响应返回给客户端。
- document.domain：将不同子域的document.domain设置为相同的主域，实现跨子域通信。
- postMessage：HTML5提供的API，允许不同源之间的窗口进行通信。
- WebSockets：提供了在单个TCP连接上进行全双工通讯的协议，不受同源策略限制。

6.2 HTTP和HTTPS：
HTTP（超文本传输协议）和HTTPS（安全超文本传输协议）是两种网络传输协议。

- HTTP：是一种不安全的协议，数据在传输过程中以明文形式传送，容易被截取和篡改。
- HTTPS：是HTTP的安全版本，通过SSL/TLS协议提供数据加密、数据完整性验证和身份验证，保证了数据传输的安全性。

HTTPS相比HTTP的优势包括：

- 加密：防止数据在传输过程中被窃听和篡改。
- 身份验证：确保用户访问的网站是服务器提供的真实网站。
- 数据完整性：验证数据在传输过程中未被篡改。

随着网络安全意识的提高，越来越多的网站和应用转向使用HTTPS协议。搜索引擎如Google也倾向于对HTTPS网站给予更高的排名。此外，某些新的Web功能（如地理位置API、Service Workers等）只能在HTTPS环境下使用。

第七章 WEB安全篇

​	7.1 XSS攻击：
XSS（跨站脚本攻击，Cross-Site Scripting）是一种常见的网络安全漏洞，攻击者通过在目标网站上注入恶意脚本，当其他用户浏览该网站时执行这些脚本，从而窃取用户信息或进行其他恶意操作。防御措施包括：
- 对用户输入进行验证和转义，避免直接插入HTML、JavaScript等代码。
- 使用CSP（内容安全策略）限制资源加载和执行。
- 设置HTTPOnly属性，防止JavaScript访问Cookie。

7.2 SQL注入：
SQL注入是攻击者通过将SQL命令插入到Web表单提交或页面请求的查询字符串，从而欺骗服务器执行恶意的SQL命令。防御措施包括：
- 使用参数化查询或预编译语句，避免直接将用户输入拼接到SQL语句中。
- 对用户输入进行严格的验证。
- 限制数据库权限，确保Web应用使用的数据库账户只具有必要的权限。

7.3 接口安全：
接口（API）安全是指保护网络接口不受到未授权访问和攻击。防御措施包括：
- 使用OAuth、JWT等认证机制对用户和第三方应用进行身份验证。
- 对数据进行加密传输，使用HTTPS协议。
- 对API访问进行限制，如通过API网关实施速率限制和IP黑名单。

7.4 CSRF攻击（XSRF）：
CSRF（跨站请求伪造，Cross-Site Request Forgery）攻击是指攻击者诱导用户在已认证的状态下，向Web应用发送非预期的请求。防御措施包括：
- 使用Anti-CSRF Token，确保请求是由用户意愿发起的。
- 对于敏感操作使用双重验证，如重新输入密码或发送验证码。
- 设置SameSite属性的Cookie，限制第三方网站发起的请求。

以上安全问题的防御措施都是为了减少或消除安全风险，保护用户数据和系统安全。开发者应该在设计和开发阶段就考虑这些安全措施，并进行定期的安全审计和测试。
第八章 其他类

​		8.1 Token：
Token是一种安全机制，用于在客户端和服务器之间传递验证信息。在用户登录后，服务器会生成一个Token并返回给客户端，客户端后续的请求都会携带这个Token，服务器通过验证Token来确认用户的身份。Token常用于无状态的认证机制，如RESTful API的安全通信。

8.2 SEO：
SEO（搜索引擎优化，Search Engine Optimization）是一系列优化网站的方法和技术，目的是提高网站在搜索引擎中的排名，从而吸引更多的访问者。SEO包括关键词优化、内容质量提升、网站结构优化、提高页面加载速度、建立反向链接、使用合适的meta标签等策略。

8.3 JWT认证：
JWT（JSON Web Tokens）是一种开放标准（RFC 7519），用于在网络应用环境间传递声明（claim）。JWT通常用于身份验证和信息交换，它允许在双方之间传递安全可靠的信息。JWT包含三部分：头部（Header）、载荷（Payload）和签名（Signature）。头部通常包含令牌的类型和加密算法；载荷包含声明信息；签名用于验证消息的真实性和完整性。使用JWT的好处包括自包含、易于传输和跨语言支持。

ç
        JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
        信息传输、授权
        JWT的认证流程
        1.前端把账号密码发送给后端的接口
        2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。
        3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内
        4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
        5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
        简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。


jwt认证过期如何做到无感知刷新



		JWT认证过期的无感知刷新通常涉及到使用两个令牌：访问令牌（Access Token）和刷新令牌（Refresh Token）。访问令牌具有较短的有效期，而刷新令牌具有较长的有效期。当访问令牌过期时，可以使用刷新令牌来获取新的访问令牌，而用户无需重新登录。以下是实现无感知刷新的一种常见流程：

1. 用户使用用户名和密码登录。
2. 服务器验证用户凭据，发放访问令牌和刷新令牌。
3. 用户访问需要认证的资源时，携带访问令牌。
4. 服务器验证访问令牌，如果有效，则允许用户访问资源。
5. 当访问令牌即将过期或已过期时，客户端会自动使用刷新令牌向认证服务器请求新的访问令牌。
6. 服务器验证刷新令牌，如果有效，发放新的访问令牌。
7. 客户端使用新的访问令牌继续访问资源。

在客户端实现时，可以通过拦截器（interceptor）来检查每个请求的响应状态。如果检测到访问令牌过期的错误（例如，HTTP 401 Unauthorized），则自动发送刷新令牌请求。如果刷新令牌请求成功，更新本地存储的访问令牌，并重试原始请求。这样用户就不会感知到令牌的刷新过程。

需要注意的是，刷新令牌的安全性至关重要，因为它可以用来获取新的访问令牌。因此，刷新令牌的存储和传输需要特别小心，以防止泄露。此外，服务器端也应该实现相应的逻辑来处理刷新令牌的失效和替换。