第一章 基础篇
　
​		1.1 HTML			

​				：行内元素有哪些？块级元素有哪些？ 空(void)元素有哪些？

```
行内元素：span、img、input...
块级元素：div、footer、header、section、p、h1...h6...
空元素：br、hr...


元素之间的转换问题：
display: inline;  			把某元素转换成了行内元素      ===>不独占一行的，并且不能设置宽高
display: inline-block; 	把某元素转换成了行内块元素		 ===>不独占一行的，可以设置宽高
display: block;					把某元素转换成了块元素			   ===>独占一行，并且可以设置宽高
```

页面导入样式时，使用link和@import有什么区别？

```
区别一：link先有，后有@import（兼容性link比@import兼容）；
区别二：加载顺序差别，浏览器先加载的标签link，后加载@import
```

title与h1的区别、b与strong的区别、i与em的区别？

```
title与h1的区别：

定义：
	title：概括了网站信息，可以告诉搜索引擎或者用户关于这个网站的内容主题是什么
	h1：文章主题内容，告诉我们的网站内容最主要是什么
区别：
	title他是显示在网页标题上、h1是显示在网页内容上
	title比h1添加的重要 (title > h1 ) ==》对于seo的了解
场景：
	网站的logo都是用h1标签包裹的	
```

```
b与strong的区别：

定义：
	b：实体标签，用来给文字加粗的。
	strong：逻辑标签，用来加强字符语气的。
区别：
	b标签只有加粗的样式，没有实际含义。
	strong表示标签内字符比较重要，用以强调的。
题外话：为了符合css3的规范，b尽量少用该用strong就行了。
```

```
i与em的区别：

定义：
	i:实体标签，用来做文字倾斜的。
	em：是逻辑标签，用来强调文字内容的
区别：
	i只是一个倾斜标签，没有实际含义。
	em表示标签内字符重要，用以强调的。
场景：
	i更多的用在字体图标，em术语上（医药，生物）。
```

img标签的title和alt有什么区别？

```
区别一：
	title ： 鼠标移入到图片显示的值
	alt   ： 图片无法加载时显示的值
区别二：
	在seo的层面上，抓取不到图片的内容，所以前端在写img标签的时候为了增加seo效果要加入alt属性来描述这张图是什么内容或者关键词。
```

png、jpg、gif 这些图片格式解释一下，分别什么时候用？

```
png:无损压缩，尺寸体积要比jpg/jpeg的大，适合做小图标。
jpg:采用压缩算法，有一点失真，比png体积要小，适合做中大图片。
gif:一般是做动图的。
webp：同时支持有损或者无损压缩，相同质量的图片，webp具有更小的体积。兼容性不是特别好。
```

​		1.2 CSS

​				：介绍一下CSS的盒子模型

```
CSS的盒子模型有哪些：标准盒子模型、IE盒子模型
CSS的盒子模型区别：
	标准盒子模型：margin、border、padding、content
	IE盒子模型 ：margin、content（ border +  padding  + content ）
通过CSS如何转换盒子模型：
	box-sizing: content-box;	/*标准盒子模型*/
	box-sizing: border-box;	  /*IE盒子模型*/
```

line-height和heigh区别【大厂】

```
line-height是每一行文字的高，如果文字换行则整个盒子高度会增大（行数*行高）。
height是一个死值，就是这个盒子的高度。
```

CSS选择符有哪些？哪些属性可以继承？

```
CSS选择符：
    通配（*）
    id选择器（#）
    类选择器（.）
    标签选择器（div、p、h1...）
    相邻选择器(+)
     子元素选择器（ > ）
    属性选择器(a[href])
    
CSS属性哪些可以继承：
		文字系列：font-size、color、line-height、text-align...
***不可继承属性：border、padding、margin...
```

CSS优先级算法如何计算？

```
优先级比较：!important > 内联样式 > id > class > 标签 > 通配
```

```
CSS权重计算：
第一：内联样式（style）  权重值:1000
第二：id选择器  				 权重值:100
第三：类选择器 				  权重值:10
第四：标签&伪元素选择器   权重值:1
第五：通配、>、+         权重值:0
```

​				：用CSS画一个三角形

```
用边框画（border）,例如：
{
		width: 0;
		height: 0;

		border-left:100px solid transparent;
		border-right:100px solid transparent;
		border-top:100px solid transparent;
		border-bottom:100px solid #ccc;
}
```

一个盒子不给宽度和高度如何水平垂直居中？

##### 方式一：

```
<div class='container'>
	<div class='main'>main</div>
</div>

.container{
		display: flex;
		justify-content: center;
		align-items: center;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		background: red;
}
```

##### 方式二：

```
<div class='container'>
	<div class='main'>main</div>
</div>

.container{
		position: relative;
		width: 300px;
		height: 300px;
		border:5px solid #ccc;
}
.main{
		position: absolute;
		left:50%;
		top:50%;
		background: red;
		transform: translate(-50%,-50%);
}
```

​				：display有哪些值？说明他们的作用。

```
none     			隐藏元素
block    			把某某元素转换成块元素
inline   			把某某元素转换成内联元素
inline-block 	把某某元素转换成行内块元素
```

​				：对BFC规范(块级格式化上下文：block formatting context)的理解？

```
BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

1. 了解BFC ： 块级格式化上下文。
2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。
3. 如何触发BFC：


BFC可以通过以下方式创建：

根元素（<html>）。
浮动元素（元素的float不是none）。
绝对定位元素（元素的position为absolute或fixed）。
display为inline-block、table-cells、flex。
overflow不是visible的块元素。
fieldset元素。

BFC的作用
BFC有一些特性，这些特性可以用于解决各种布局问题：

内部的Box会在垂直方向上一个接一个地放置。
Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。
每个元素的左外边缘与包含块的左边缘相接触（对于从右到左的格式，右边缘相接触）。
BFC的区域不会与float元素的布局区域重叠。
计算BFC的高度时，浮动元素也参与计算。
BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。
BFC的应用
BFC可以用于以下场景：
防止margin重叠：相邻的块级元素垂直方向的margin会发生重叠，可以通过创建BFC来避免这个问题。
包含浮动元素（清除浮动）：未创建BFC的父元素无法自动包含其浮动的子元素，通过创建BFC可以解决外部元素高度塌陷的问题。
创建自适应两栏布局：可以利用BFC防止元素被浮动元素覆盖，从而实现两栏布局。
防止文字环绕：可以通过BFC避免文字围绕浮动元素。

```

清除浮动有哪些方式？

```
1. 触发BFC
2. 多创建一个盒子，添加样式：clear: both;
3. after方式
	ul:after{
			content: '';
			display: block;
			clear: both;
	}
```

在网页中的应该使用奇数还是偶数的字体？为什么呢？

```
偶数 : 让文字在浏览器上表现更好看。

另外说明：ui给前端一般设计图都是偶数的，这样不管是布局也好，转换px也好，方便一点。
```

position有哪些值？分别是根据什么定位的？

```
static [默认]  没有定位
fixed  固定定位，相对于浏览器窗口进行定位。
relative  相对于自身定位，不脱离文档流。
absolute	相对于第一个有relative的父元素，脱离文档流。


relative和absolute区别
1. relative不脱离文档流 、absolute脱离文档流
2. relative相对于自身 、 absolute相对于第一个有relative的父元素
3. relative如果有left、right、top、bottom ==》left、top
	 absolute如果有left、right、top、bottom ==》left、right、top、bottom
```

写一个左中右布局占满屏幕，其中左、右俩块固定宽200，中间自适应宽，要求先加载中间块，请写出结构及样式。

1. **使用浮动（Floats）**:
```css
.container {
  overflow: hidden;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
  float: left; /* 左侧栏浮动 */
}
.right {
  float: right; /* 右侧栏浮动 */
}
.center {
  margin: 0 200px; /* 中间栏的外边距等于侧栏宽度 */
}
```

2. **使用Flexbox**:
```css
.container {
  display: flex;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
}
.center {
  flex: 1; /* 中间栏占据剩余空间 */
}
```

3. **使用CSS Grid**:
```css
.container {
  display: grid;
  grid-template-columns: 200px auto 200px; /* 三列的宽度 */
}
.left {
  grid-column: 1;
}
.center {
  grid-column: 2;
}
.right {
  grid-column: 3;
}
```

4. **使用绝对定位（Absolute Positioning）**:
```css
.container {
  position: relative;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
  position: absolute;
  top: 0;
}
.left {
  left: 0;
}
.right {
  right: 0;
}
.center {
  margin: 0 200px; /* 中间栏的外边距等于侧栏宽度 */
}
```

5. **使用表格布局（Table Layout）**:
```css
.container {
  display: table;
  width: 100%;
}
.left, .center, .right {
  display: table-cell;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
}
.center {
  /* 中间栏自动填充剩余空间 */
}
```


什么是CSS reset？

```
reset.css   		是一个css文件，用来重置css样式的。
normalize.css 	为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。
```

css sprite是什么,有什么优缺点

```
1. 是什么
	把多个小图标合并成一张大图片。
2. 优缺点
	优点：减少了http请求的次数，提升了性能。
	缺点：维护比较差（例如图片位置进行修改或者内容宽高修改）
```

display: none;与visibility: hidden;的区别

```
1. 占用位置的区别
display: none; 				是不占用位置的
visibility: hidden;   虽然隐藏了，但是占用位置

1. 重绘和回流的问题

visibility: hidden; 、 display: none;  产生重绘
display: none;     还会产生一次回流

产生回流一定会造成重绘，但是重绘不一定会造成回流。

产生回流的情况：改变元素的位置(left、top...)、显示隐藏元素....
产生重绘的情况：样式改变、换皮肤
```

opacity 和 rgba区别

```
共同性：实现透明效果

1. opacity 取值范围0到1之间，0表示完全透明，1表示不透明
2. rgba   R表示红色，G表示绿色，B表示蓝色，取值可以在正整数或者百分数。A表示透明度取值0到1之间

区别：继承的区别
opacity会继承父元素的opacity属性，而RGBA设置的元素的后代元素不会继承不透明属性。
```

​		1.3 JavaScript基础

​				：延迟加载JS有哪些方式？

```
延迟加载：async、defer
		例如：<script defer type="text/javascript" src='script.js'></script>
		
defer : 等html全部解析完成，才会执行js代码，顺次执行js脚本。
async : async是和html解析同步的（一起的），不是顺次执行js脚本（谁先加载完谁先执行）。
```

​				：JS数据类型有哪些？

```
基本类型：string、number、boolean、undefined、null、symbol、bigint
引用类型：object

NaN是一个数值类型，但是不是一个具体的数字。
```

​				：JS数据类型	

##### 一：

```
console.log( true + 1 );     			//2
console.log( 'name'+true );  			//nametrue
console.log( undefined + 1 ); 		//NaN
console.log( typeof undefined ); //undefined
```

##### 二：

```  
console.log( typeof(NaN) );       //number
console.log( typeof(null) );      //object
```

​				：null和undefined的区别

```
1. 作者在设计js的都是先设计的null（为什么设计了null：最初设计js的时候借鉴了java的语言）
2. null会被隐式转换成0，很不容易发现错误。
3. 先有null后有undefined，出来undefined是为了填补之前的坑。

具体区别：JavaScript的最初版本是这样区分的：null是一个表示"无"的对象（空对象指针），转为数值时为0；undefined是一个表示"无"的原始值，转为数值时为NaN。
```

​				：==和===有什么不同？

```
==  :  比较的是值
		
		string == number || boolean || number ....都会隐式转换
		通过valueOf转换（valueOf() 方法通常由 JavaScript 在后台自动调用，并不显式地出现在代码中。）

=== ： 除了比较值，还比较类型
```

​				：JS微任务和宏任务

```
1. js是单线程的语言。
2. js代码执行流程：同步执行完==》事件循环
	同步的任务都执行完了，才会执行事件循环的内容
	进入事件循环：请求、定时器、事件....
3. 事件循环中包含：【微任务、宏任务】
微任务：promise.then
宏任务：setTimeout..

要执行宏任务的前提是清空了所有的微任务

流程：同步==》事件循环【微任务和宏任务】==》微任务==》宏任务=》微任务...

```

​				：JS作用域

```
1. 除了函数外，js是没有块级作用域。
2. 作用域链：内部可以访问外部的变量，但是外部不能访问内部的变量。
	 注意：如果内部有，优先查找到内部，如果内部没有就查找外部的。
3. 注意声明变量是用var还是没有写（window.）
4. 注意：js有变量提升的机制【变量悬挂声明】
5. 优先级：声明变量 > 声明普通函数 > 参数 > 变量提升
```


```
1. 本层作用域有没有此变量【注意变量提升】
2. 注意：js除了函数外没有块级作用域
3. 普通声明函数是不看写函数的时候顺序
```

##### 一：

```
function c(){
	var b = 1;
	function a(){
		console.log( b );
		var b = 2;
		console.log( b );
	}
	a();
	console.log( b );
}
c();
```
运行结果：
undefined
2
1
##### 二：

```
var name = 'a';
(function(){
	if( typeof name == 'undefined' ){
		var name = 'b';
		console.log('111'+name);
	}else{
		console.log('222'+name);
	}
})()
```
111b
##### 三：

```
function fun( a ){
	var a = 10;
	function a(){}
	console.log( a );
}
fun( 100 );
```

10

JS对象

JS对象注意点：

```
1. 对象是通过new操作符构建出来的，所以对象之间不等(除了引用外)；
2. 对象注意：引用类型(共同一个地址)；
3. 对象的key都是字符串类型；
4. 对象如何找属性|方法；
	查找规则：先在对象本身找 ===> 构造函数中找 ===> 对象原型中找 ===> 构造函数原型中找 ===> 对象上一层原型查找
```

##### 一：

```
 [1,2,3] === [1,2,3]   //false
```

##### 二：

```
var obj1 = {
	a:'hellow'
}
var obj2 = obj1;
obj2.a = 'world';
console.log(obj1); 	//{a:world}
(function(){
	console.log(a); 	//undefined
	var a = 1;
})();
```

##### 三：

```
var a = {}
var b = {
	key:'a'
}
var c = {
	key:'c'
}

a[b] = '123';
a[c] = '456';

console.log( a[b] ); // 456
```

​				：JS作用域+this指向+原型的

##### 一：

```
function Foo(){
	getName = function(){console.log(1)} //注意是全局的window.
	return this;
}

Foo.getName = function(){console.log(2)}
Foo.prototype.getName = function(){console.log(3)}
var getName = function(){console.log(4)}
function getName(){
	console.log(5)
}

Foo.getName();    //2
getName(); 		  //4
Foo().getName();  //1
getName();		  //1
new Foo().getName();//3
```
这段代码涉及到 JavaScript 的作用域、函数声明提升、以及构造函数的行为。让我们一步步分析这段代码的执行过程：

函数声明提升：函数声明 function getName(){console.log(5)} 会被提升到代码的顶部，但是它会被后面的变量声明 var getName 覆盖。尽管如此，由于 var 关键字声明的变量也会被提升，但不会覆盖函数声明，所以在代码执行之前，getName 实际上是指向 function getName(){console.log(5)} 的。

变量赋值：变量 getName 被赋值为 function(){console.log(4)}，这个赋值操作覆盖了原来的函数声明。

Foo.getName();：调用 Foo 对象上的 getName 方法，打印 2。

getName();：调用当前作用域内的 getName 函数，由于第2步的赋值操作，此时它打印 4。

Foo().getName();：首先调用 Foo 函数。由于 Foo 函数内部的 getName = function(){console.log(1)} 没有使用 var、let 或 const 关键字，这实际上创建了一个全局变量 getName 并赋值为 function(){console.log(1)}。这个赋值操作覆盖了之前的 getName 函数。然后 Foo 函数返回 this，在非严格模式下，this 默认指向全局对象 window。因此，Foo().getName(); 相当于调用 window.getName();，打印 1。

getName();：由于第5步中全局的 getName 函数已经被修改为 function(){console.log(1)}，所以这次调用打印 1。

new Foo().getName();：使用 new 关键字调用 Foo 函数会创建一个新的对象，这个对象的原型链指向 Foo.prototype。由于在 Foo 函数体内没有修改 this 指向的对象的 getName 方法，所以 new Foo().getName(); 调用的是 Foo.prototype 上的 getName 方法，打印 3。

总结来说，Foo().getName(); 和 getName(); 都打印 1，因为 Foo() 函数调用时修改了全局的 getName 函数。


##### 二：

```
var o = {
	a:10,
	b:{
		a:2,
		fn:function(){
			console.log( this.a ); // 2
			console.log( this );   //代表b对象
		}
	}
}
o.b.fn();
```

##### 三：

```
window.name = 'ByteDance';
function A(){
	this.name = 123;
}
A.prototype.getA = function(){
	console.log( this );
	return this.name + 1;
}
let a = new A();
let funcA = a.getA;
funcA();  //this代表window
```

##### 四：

```
var length = 10;
function fn(){
	return this.length + 1;
}
var obj = {
	length:5,
	test1:function(){
		return fn();
	}
}
obj.test2 = fn;
console.log( obj.test1() ); 							//1
console.log( fn()===obj.test2() ); 				//false
console.log( obj.test1() == obj.test2() ); //false
```


现在，我们来看调用的结果：

console.log( obj.test1() ); 当调用 obj.test1() 时，test1 函数内部调用 fn()。由于 fn 是直接调用的（不是作为对象的方法调用），在非严格模式下，this 会指向全局对象（在浏览器中是 window）。因此，this.length 是全局的 length，即 10。所以 obj.test1() 返回 10 + 1，即 11。但是由于数组的 length 属性是存在的，而且 this 在这个例子中指向 window 对象，而 window 对象有一个 length 属性，用来返回窗口中包含的框架数量。假设没有框架，window.length 的值将是 0。因此，obj.test1() 返回 0 + 1，即 1。

console.log( fn() === obj.test2() ); 这里再次直接调用 fn()，this 依然指向全局对象，所以 fn() 返回 1。obj.test2() 是作为 obj 的方法调用的，所以 this 指向 obj，obj.test2() 返回 5 + 1，即 6。因此，fn() 和 obj.test2() 返回的值不相等，结果是 false。

console.log( obj.test1() == obj.test2() ); 根据之前的分析，obj.test1() 返回 1，而 obj.test2() 返回 6。这两个值不相等，所以结果是 false。
​				：JS判断变量是不是数组，你能写出哪些方法？

##### 方式一：isArray

```
var arr = [1,2,3];
console.log( Array.isArray( arr ) );
```

##### 方式二：instanceof  【可写,可不写】

```
var arr = [1,2,3];
console.log( arr instanceof Array );
```

##### 方式三：原型prototype

```
var arr = [1,2,3];
console.log( Object.prototype.toString.call(arr).indexOf('Array') > -1 );
```

#### 方式四：isPrototypeOf()

```
var arr = [1,2,3];
console.log(  Array.prototype.isPrototypeOf(arr) )
```

#### 方式五：constructor

```
var arr = [1,2,3];
console.log(  arr.constructor.toString().indexOf('Array') > -1 )
```

​				：slice是干嘛的、splice是否会改变原数组

```
1. slice是来截取的
	参数可以写slice(3)、slice(1,3)、slice(-3)
	返回的是一个新的数组
2. splice 功能有：插入、删除、替换
	返回：删除的元素
	该方法会改变原数组
```

JS数组去重

##### 方式一：new set

```
var arr1 = [1,2,3,2,4,1];
function unique(arr){
	return [...new Set(arr)]
}
console.log(  unique(arr1) );
```

##### 方式二：indexOf

```
var arr2 = [1,2,3,2,4,1];
function unique( arr ){
	var brr = [];
	for( var i=0;i<arr.length;i++){
		if(  brr.indexOf(arr[i]) == -1 ){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr2) );
```

##### 方式三：sort

```
var arr3 = [1,2,3,2,4,1];
function unique( arr ){
	arr = arr.sort();
	var brr = [];
	for(var i=0;i<arr.length;i++){
		if( arr[i] !== arr[i-1]){
			brr.push( arr[i] );
		}
	}
	return brr;
}
console.log( unique(arr3) );
```

找出多维数组最大值

```
function fnArr(arr){
	var newArr = [];
	arr.forEach((item,index)=>{
		newArr.push( Math.max(...item)  )
	})
	return newArr;
}
console.log(fnArr([
	[4,5,1,3],
	[13,27,18,26],
	[32,35,37,39],
	[1000,1001,857,1]
]));
```

给字符串新增方法实现功能

给字符串对象定义一个addPrefix函数，当传入一个字符串str时，它会返回新的带有指定前缀的字符串，例如：

console.log( 'world'.addPrefix('hello') )  控制台会输出helloworld

```
解答：
String.prototype.addPrefix = function(str){
	return str  + this;
}
console.log( 'world'.addPrefix('hello') )
```

找出字符串出现最多次数的字符以及次数

```
var str = 'aaabbbbbccddddddddddx';
var obj = {};
for(var i=0;i<str.length;i++){
	var char = str.charAt(i);
	if( obj[char] ){
		obj[char]++;
	}else{
		obj[char] = 1;
	}
}
console.log( obj );
//统计出来最大值
var max = 0;
for( var key in obj ){
	if( max < obj[key] ){
		max = obj[key];
	}
}
//拿最大值去对比
for( var key in obj ){
	if( obj[key] == max ){
		console.log('最多的字符是'+key);
		console.log('出现的次数是'+max);
	}
}
```

​				：new操作符具体做了什么

```
1. 创建了一个空的对象
2. 将空对象的原型，指向于构造函数的原型
3. 将空对象作为构造函数的上下文（改变this指向）
4. 对构造函数有返回值的处理判断
```
function customNew(constructor, ...args) {
    // 1. 创建一个空的对象
    var obj = {};

    // 2. 将空对象的原型指向构造函数的原型
    Object.setPrototypeOf(obj, constructor.prototype);

    // 3. 将空对象作为构造函数的上下文（改变this指向）
    var result = constructor.apply(obj, args);

    // 4. 对构造函数有返回值的处理判断
    // 如果构造函数返回的是一个对象，则返回这个对象
    // 否则返回步骤1创建的对象
    return (result !== null && typeof result === 'object') || typeof result === 'function' ? result : obj;
}

// 使用示例
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log('Hello, my name is ' + this.name);
};

// 使用 customNew 来模拟 new 操作符
var person = customNew(Person, 'Alice', 30);
person.greet(); // 输出: Hello, my name is Alice

```
function Fun( age,name ){
	this.age = age;
	this.name = name;
}
function create( fn , ...args ){
	//1. 创建了一个空的对象
	var obj = {}; //var obj = Object.create({})
	//2. 将空对象的原型，指向于构造函数的原型
	Object.setPrototypeOf(obj,fn.prototype);
	//3. 将空对象作为构造函数的上下文（改变this指向）
	var result = fn.apply(obj,args);
	//4. 对构造函数有返回值的处理判断
	return result instanceof Object ? result : obj;
}
console.log( create(Fun,18,'张三')   )
```

​				：闭包

```
1. 闭包是什么
	闭包是一个函数加上到创建函数的作用域的连接，闭包“关闭”了函数的自由变量。
2. 闭包可以解决什么问题【闭包的优点】
	2.1 内部函数可以访问到外部函数的局部变量
	2.2 闭包可以解决的问题
			var lis = document.getElementsByTagName('li');
      for(var i=0;i<lis.length;i++){
        (function(i){
          lis[i].onclick = function(){
            alert(i);
          }
        })(i)
      }
3. 闭包的缺点
	3.1 变量会驻留在内存中，造成内存损耗问题。
				解决：把闭包的函数设置为null
  3.2 内存泄漏【ie】 ==> 可说可不说，如果说一定要提到ie
  为了避免因不正确使用闭包而导致的内存泄漏，可以采取以下措施：

有意识地使用闭包：只在需要的时候使用闭包，并且清楚地了解闭包的工作原理。

避免循环引用：如果闭包中的DOM元素引用了闭包函数，而闭包函数又引用了这个DOM元素，这就形成了一个循环引用。确保在不需要时解除这种引用。

及时释放资源：在不再需要闭包时，确保释放闭包占用的资源。例如，如果闭包被用作事件处理器，当移除DOM元素时，也应该移除相关的事件监听器。

使用弱引用：在支持弱引用的环境中（例如使用WeakMap或WeakSet），可以考虑使用弱引用来存储对DOM元素的引用，这样可以避免阻止垃圾回收。

分离DOM元素和JavaScript逻辑：尽量避免在JavaScript对象中直接存储对DOM元素的引用。可以使用ID或类名来查询DOM元素，而不是在JavaScript对象中保存它们的引用。

使用事件委托：使用事件委托可以减少事件处理器的数量，从而减少闭包的创建。事件委托是指将事件监听器绑定到父元素上，利用事件冒泡原理来处理子元素的事件。

监控和分析内存使用：使用浏览器的开发者工具来监控内存使用情况。定期进行性能分析和内存泄漏检测，以便及时发现并解决问题。

代码审查和重构：定期对代码进行审查，重构那些可能导致内存泄漏的部分，尤其是那些复杂的闭包结构。




在Internet Explorer（IE）浏览器中，内存泄漏通常是由于不当的JavaScript编码实践导致的，尤其是在早期版本的IE中，这些问题更为常见。内存泄漏指的是当页面上的元素或者代码不再需要使用时，由于某些原因，它们所占用的内存没有被浏览器垃圾回收机制回收，导致内存的持续占用。在IE中，内存泄漏可能由以下几种情况引起：

循环引用：IE的早期版本中，JavaScript对象和DOM对象是由两个不同的垃圾回收机制处理的。如果JavaScript对象和DOM对象相互引用，就可能产生循环引用，导致内存泄漏。

全局变量：无意中创建的全局变量可能不会被回收，尤其是当它们引用了DOM元素时。

闭包：不正确使用闭包可能导致内存泄漏，因为闭包会保持对外部变量的引用。

事件处理器：在DOM元素上注册的事件处理器如果没有被正确移除，可能会导致内存泄漏。

COM对象：IE中使用ActiveX或其他COM对象时，如果没有正确管理这些对象的生命周期，也可能导致内存泄漏。
```

​				：原型链

```
1. 原型可以解决什么问题
	对象共享属性和共享方法
2. 谁有原型
函数拥有：prototype
对象拥有：__proto__
3. 对象查找属性或者方法的顺序
	先在对象本身查找 --> 构造函数中查找 --> 对象的原型 --> 构造函数的原型中 --> 当前原型的原型中查找
4. 原型链
	4.1 是什么？：就是把原型串联起来
	4.2 原型链的最顶端是null
```

​				： JS继承有哪些方式

##### 方式一：ES6

```
class Parent{
	constructor(){
		this.age = 18;
	}
}

class Child extends Parent{
	constructor(){
		super();
		this.name = '张三';
	}
}
let o1 = new Child();
console.log( o1,o1.name,o1.age );
```

##### 方式二：原型链继承

```
function Parent(){
	this.age = 20;
}
function Child(){
	this.name = '张三'
}
Child.prototype = new Parent();
let o2 = new Child();
console.log( o2,o2.name,o2.age );
```

##### 方式三：借用构造函数继承

```
function Parent(){
	this.age = 22;
}
function Child(){
	this.name = '张三'
	Parent.call(this);
}
let o3 = new Child();
console.log( o3,o3.name,o3.age );
```

##### 方式四：组合式继承

```
function Parent(){
	this.age = 100;
}
function Child(){
	Parent.call(this);
	this.name = '张三'
}
Child.prototype = new Parent();
let o4 = new Child();
console.log( o4,o4.name,o4.age );
```

​				：说一下call、apply、bind区别

##### 共同点：功能一致

```
可以改变this指向

语法： 函数.call()、函数.apply()、函数.bind()
```

##### 区别：

```
1. call、apply可以立即执行。bind不会立即执行，因为bind返回的是一个函数需要加入()执行。
2. 参数不同：apply第二个参数是数组。call和bind有多个参数需要挨个写。
```

##### 场景：

```
1. 用apply的情况
var arr1 = [1,2,4,5,7,3,321];
console.log( Math.max.apply(null,arr1) )

2. 用bind的情况
var btn = document.getElementById('btn');
var h1s = document.getElementById('h1s');
btn.onclick = function(){
	console.log( this.id );
}.bind(h1s)
```

​				：sort背后原理是什么？

```
V8 引擎 sort 函数只给出了两种排序 InsertionSort 和 QuickSort，数量小于10的数组使用 InsertionSort，比10大的数组则使用 QuickSort。

之前的版本是：插入排序和快排，现在是冒泡

原理实现链接：https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js

***710行代码开始***
```

​				：深拷贝和浅拷贝

```
共同点：复制

1. 浅拷贝：只复制引用，而未复制真正的值。
var arr1 = ['a','b','c','d'];
var arr2 = arr1;

var obj1 = {a:1,b:2}
var obj2 = Object.assign(obj1);

2. 深拷贝：是复制真正的值 （不同引用）
function clone(data){
  if(typeof data==='symbol'){           //Symbol
    return Symbol.for(data.description);
  }else if(typeof data!='object'){      //基本类型
    return data;
  }else if(data instanceof Array){      //Array
    return data.map(item=>clone(item));
  }else if(data.constructor===Object){   //Json
    let res={};
    for(let key in data){
      res[key]=clone(data[key]);
    }
    return res;
  }else{                                //系统对象、自定义对象
    return new data.constructor(data);
  }
}
 
```

​				：localStorage、sessionStorage、cookie的区别

```
公共点：在客户端存放数据
区别：
1. 数据存放有效期
		sessionStorage : 仅在当前浏览器窗口关闭之前有效。【关闭浏览器就没了】
		localStorage   : 始终有效，窗口或者浏览器关闭也一直保存，所以叫持久化存储。
		cookie				 : 只在设置的cookie过期时间之前有效，即使窗口或者浏览器关闭也有效。
2. localStorage、sessionStorage不可以设置过期时间
	 cookie 有过期时间，可以设置过期（把时间调整到之前的时间，就过期了）
3. 存储大小的限制
	cookie存储量不能超过4k
	localStorage、sessionStorage不能超过5M
	
	****根据不同的浏览器存储的大小是不同的。
```

​		1.4 H5/C3

​				：什么是语义化标签

```
1. 易读性和维护性更好。
2. seo成分会更好，蜘蛛抓取更好。
3. IE8不兼容HTML5标签的。解决：可以通过html5shiv.js去处理。
```

​				：::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。

```
1. 区别
	:是伪类、::伪元素  ===》是为了做区分

2.是什么？作用
	元素before之前 、 元素after之后
	作用：清除浮动、样式布局上也有作用
```

​				：如何关闭IOS键盘首字母自动大写

```
<input type="text" autocapitalize='off'>
```

​				：怎么让Chrome支持小于12px 的文字？

```
Chrome默认字体大小是：16px
**每个浏览器默认字体大小可能都不一样

<style type="text/css">
div{
	font-size:10px;
}
div span{
	display: inline-block;
	-webkit-transform:scale(1.6);
}
</style>
zoom 和 transform: scale() 都可以用来改变元素的大小，但它们之间存在一些关键区别：

兼容性：

zoom 属性不是一个标准的 CSS 属性，它主要被一些旧版本的浏览器支持，如 Internet Explorer。在其他浏览器中可能不起作用或者表现不一致。
transform: scale() 是一个标准的 CSS3 属性，得到了所有现代浏览器的广泛支持。
布局影响：

zoom 更像是直接改变了元素的实际大小，它会影响布局，因为元素占据的空间会随之改变。
transform: scale() 通过改变元素的渲染大小来缩放元素，但不会改变元素在文档流中占据的空间。这意味着即使元素被缩放了，它原本占据的空间仍然保持不变。
动画和过渡：

transform: scale() 更适合用于动画和过渡效果，因为它是为此设计的，并且可以与其他 transform 函数（如 rotate、translate 等）一起使用。
zoom 不是为动画设计的，因此在动画和过渡方面的表现可能不如 transform。
语法和使用：

zoom 的值通常是一个数字或百分比，表示元素的缩放级别。
transform: scale() 可以接受一个或两个参数，分别表示水平和垂直方向的缩放比例，如 scale(1.5) 或 scale(1.5, 2)。
总的来说，transform: scale() 更推荐用于现代网页设计，因为它是一个标准的 CSS 属性，提供了更好的兼容性和灵活性。而 zoom 属性可能在某些特定情况下有用，但由于其非标准和兼容性问题，一般不建议使用。
```

​				：rem和em区别

```
相对于font-size

em针对于父元素的font-size
rem针对于根(html)元素的font-size
```

​				：ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉

```
<style>
	a,button,input,textarea{
		-webkit-tap-highlight-color: rgba(0,0,0,0);
	}
</style>
```

​				webkit表单输入框placeholder的颜色值能改变吗？

```
<style type="text/css">
	input::-webkit-input-placeholder{
		color:red;
	}
</style>
```

​				：禁止ios长按时触发系统的菜单，禁止ios&android长按时下载图片

```
禁止ios 长按时触发系统的菜单，禁止ios&android长按时下载图片
html,body{
	touch-callout: none;
	-webkit-touch-callout: none;
	
	user-select:none;
	-webkit-user-select:none;
}
```

​				：禁止ios和android用户选中文字

```
html,body{
	user-select:none;
	-webkit-user-select:none;
}
```

​				：自适应

```
淘宝无限适配【移动端】：淘宝无限适配 + 布局单位使用rem
```

​				：响应式

```
1. 是什么？
	一个URL可以响应多端
2. 语法结构
	@media only screen and (max-width: 1000px){
		ul li:last-child{
			display: none;
		}
	}

	only : 可以排除不支持媒体查询的浏览器
	screen ： 设备类型
	max-width | max-height
	min-width | min-height 
3. 响应式图片【性能优化】
	<picture>
		<source srcset="1.jpg" media='(min-width:1000px)'>
		<source srcset="2.jpg" media='(min-width:700px)'>
		<img srcset="3.jpg">
	</picture>
```

布局方案

```
一、什么情况下采用响应式布局
	
	数据不是特别多，用户量不是特别大，纯展示类的项目适合响应式布局
	
	例如：公司的官网、专题页面
	
	特别追求性能的项目，不太适合响应式，因为如果添加了很多的响应式就会造成加载速度变慢。

二、pc + 移动端应该做什么样的布局方案
	注意：访问量还可以或者比较大，类似于淘宝网。
	
	pc是一套，会加入一点点响应式。
	移动端是一套，会使用自适应的布局方式。

三、pc的设计图

	ui：1980
	笔记本电脑：1280
	ui图的宽度和电脑的宽度不对应该怎么办？
		1. 把ui图进行等比缩放，缩放成和电脑一样的尺寸
		2. 换1980的电脑
		
四、移动端的设计图

	宽度：750
	因为750设计图/2就是375，正好是iphone6的尺寸，我们要把iphone6的尺寸做为基准点。
```

第二章 进阶篇

​		2.1 ES6

​				：var、let、const区别

```
var、let、const 共同点都是可以声明变量的

区别一：
	var 具有变量提升的机制
	let和const没有变量提升的机制
区别二：
	var 可以多次声明同一个变量
	let和const不可以多次声明同一个变量
区别三：
	var、let声明变量的
	const声明常量
	
	var和let声明的变量可以再次赋值，但是const不可以再次赋值了。
区别四：
	var声明的变量没有自身作用域
	let和const声明的变量有自身的作用域
```

​				：作用域

一：let和const没有变量提升性

```
console.log( str );//undefined
var str = '你好';

console.log( num );//报错
let num = 10;
```

二：

```
function demo(){
	var n = 2;
	if( true ){
		var n = 1;
	}
	console.log( n );//1
}
demo();


function demo(){
	let n = 2;
	if( true ){
		let n = 1;
	}
	console.log( n );//2
}
demo();
```

三：可以修改

```
const obj = {
	a:1
}
obj.a = 11111;
console.log( obj )

const arr = ['a','b','c'];
arr[0]= 'aaaaa';
console.log( arr );
```

​				：将下列对象进行合并

方式一：Object.assign

```
const a = {a:1,b:4};
const b = {b:2,c:3};

let obj1 = Object.assign(a,b);
console.log( obj1 );
```

方式二：...

```
let obj2 = {...a,...b};
console.log( obj2 );
```

方式三：自己封装方法

```
function extend( target,  source ){
	for(var key in source){
		target[key] = source[key];
	}
	return target;
}
console.log( extend(a,b) );
```

​				：箭头函数和普通函数有什么区别？

```
1. this指向的问题
	箭头函数中的this只在箭头函数定义时就决定的，而且不可修改的（call、apply、bind）
	****箭头函数的this指向定义时候、外层第一个普通函数的this
2. 箭头函数不能new（不能当作构造函数）
3. 箭头函数prototype
4. 箭头函数arguments
```

​				：Promise有几种状态

```
有三种状态：
pending（进行中）
fulfilled（已成功）
rejected（已失败）
```

​				：find和filter的区别

```
区别一：返回的内容不同
	filter 返回是新数组
	find   返回具体的内容
区别二：
	find ：匹配到第一个即返回
	filter ： 返回整体（没一个匹配到的都返回）
```

​				：some和every的区别

```
some  ==》 如果有一项匹配则返回true
every ==》 全部匹配才会返回true
```

​		2.2 webpack

​				：webpack插件

​		2.3 Git

​				：git常用命令

​				：解决冲突

​				：GitFlow

第三章 框架篇

​		3.1 Vue

​				：Vue2.x 生命周期

```
1. 有哪些生命周期
系统自带：
  beforeCreate
  created
  beforeMount
  mounted
  beforeUpdate
  updated
  beforeDestroy
  destroyed
2. 一旦进入到页面或者组件，会执行哪些生命周期，顺序。
 beforeCreate
 created
 beforeMount
 mounted
3. 在哪个阶段有$el，在哪个阶段有$data
	beforeCreate 啥也没有
	created  有data没有el
	beforeMount 有data没有el
	mounted 都有
4. 如果加入了keep-alive会多俩个生命周期
	activated、deactivated
5. 如果加入了keep-alive，第一次进入组件会执行哪些生命？
 beforeCreate
 created
 beforeMount
 mounted
 activated
6. 如果加入了keep-alive，第二次或者第N次进入组件会执行哪些生命周期？
只执行一个生命周期：activated
```

​				：谈谈你对keep-alive的了解

```
1. 是什么
vue系统自带的一个组件，功能：是来缓存组件的。===》提升性能
2. 使用场景
就是来缓存组件，提升项目的性能。具体实现比如：首页进入到详情页，如果用户在首页每次点击都是相同的，那么详情页就没必要请求N次了，直接缓存起来就可以了，当然如果点击的不是同一个，那么就直接请求。
```

​				：v-if和v-show区别

```
1. 展示形式不同
v-if是 创建一个dom节点
v-show 是display:none 、 block

2. 使用场景不同
初次加载v-if要比v-show好，页面不会做加载盒子
频繁切换v-show要比v-if好，创建和删除的开销太大了，显示和隐藏开销较小
```

​				：v-if和v-for优先级

```
v-for的优先级要比v-if高
***是在源码中体现的：function genElement
```

​				：ref是什么？

```
来获取dom的
```

​				：nextTick是什么?

```
获取更新后的dom内容
```

​				：scoped原理

```
1. 作用：让样式在本组件中生效，不影响其他组件。
2. 原理：给节点新增自定义属性，然后css根据属性选择器添加样式。
```

​				：Vue中如何做样式穿透

```
stylus样式穿透使用：>>>
sass和less使用：/deep/
通用使用：  :v-deep
```

​				：Vue组件传值

```
父组件-->子组件：

	1. 父组件：
		<user-detail :myName="name" />
    
    export default {
        components: {
            UserDetail
        }
        ......
    }
  2. 在子组件中使用props（可以是数组也可以是对象）接收即可。可以传多个属性。
  	export default {
      props: ['myName']
 		}

子组件-->父组件：

		1. 子组件
      <button @click="changeParentName">改变父组件的name</button>
      export default {
          methods: {
              //子组件的事件
              changeParentName: function() {
                  this.$emit('handleChange', 'Jack')
              }
          }
      }
    2. 父组件
      <child @handleChange="changeName"></child>

      methods: {
          changeName(name) {  
              this.name = name
          }
      }

兄弟组件之间：bus.js
```

​				：computed、methods、watch有什么区别？

```
1. computed vs methods区别
	computed是有缓存的
	methods没有缓存
2. computed vs watch区别
	watch是监听，数据或者路由发生了改变才可以响应（执行）
	computed计算某一个属性的改变，如果某一个值改变了，计算属性会监听到进行返回
	watch是当前监听到数据改变了，才会执行内部代码
```

​				：props和data优先级谁高？

```
props ===>  methods ===> data ===> computed ===>watch
```

​				：Vuex有哪些属性？

```
state、getters、mutations、actions、modules

state 类似于组件中data，存放数据
getters 类型于组件中computed
mutations 类似于组件中methods
actions 提交mutations的
modules 把以上4个属性再细分，让仓库更好管理

state: 代表应用的共享状态，是存储的核心。

getters: 类似于计算属性，允许你根据state计算新的值，可以用于派生状态。

mutations: 是唯一可以直接更改state的函数，它们应该是同步的。

actions: 类似于mutations，但它们可以包含异步操作，提交的是mutation，而不是直接变更状态。

modules: 允许将store分割成模块，每个模块拥有自己的state、mutations、actions、getters，甚至嵌套子模块。
```

​				：Vuex是单向数据流还是双向数据流？

```
Vuex是单向数据流
```

​				：Vuex中的mutaitons和actions区别

```
mutaitons   :  都是同步事物
actions     :  可以包含任意异步操作

***在调试中就看出来
```

​				：Vuex如何做持久化存储

```
Vuex本身不是持久化存储

1. 使用localStorage自己写
2. 使用vuex-persist插件
```

​				：Vue设置代理

###### vue.config.js

```
module.exports = {
  publicPath:'./',
  devServer: {
    proxy: 'http://localhost:3000'
  }
}
```

​				：Vue项目打包上线

```
1. 自测==>修改路由模式
2. 代理不生效，使用ENV
3. 修改路径
```

​				：Vue路由模式

```
路由模式有俩种：history、hash
区别：
	1. 表现形态不同
			history:http://localhost:8080/about
			hash:http://localhost:8080/#/about
	2. 跳转请求
			history : http://localhost:8080/id   ===>发送请求
			hash 	  : 不会发送请求
	3. 打包后前端自测要使用hash，如果使用history会出现空白页
```

​				：介绍一下SPA以及SPA有什么缺点

```
SPA是什么？单页面应用
缺点：
	1. SEO优化不好
	2. 性能不是特别好
```

​				：Vue路径传值

```
1. 显式
	http://localhost:8080/about?a=1
	1.1 传：this.$router.push({
  			path:'/about',
  			query:{
  				a:1
  			}
  		})
  1.2 接：this.$route.query.a
  
2. 隐式
	http://localhost:8080/about
	2.1 传：this.$router.push({
  			name:'About',
  			params:{
  				a:1
  			}
  		})
  2.2 接：this.$route.params.a
```

​				：路由导航守卫有哪些	

```
全局、路由独享、组件内
在Vue中，导航守卫可以分为全局守卫、路由独享守卫和组件内守卫。

1. 全局守卫：
   - `beforeEach`: 在路由进入之前全局调用。
   - `beforeResolve`: 在路由解析（解析异步组件和钩子）之后，导航被确认之前，全局调用。
   - `afterEach`: 在路由确认进入后全局调用。

2. 路由独享守卫：
   - `beforeEnter`: 在路由配置上直接定义，只在该路由被访问时调用。

3. 组件内守卫：
   - `beforeRouteEnter`: 在渲染该组件的对应路由被确认前调用。
   - `beforeRouteUpdate`: 在当前路由改变，但是该组件被复用时调用。
   - `beforeRouteLeave`: 在导航离开该组件的对应路由时调用。
	
使用场景：判断是否登录，如果登录就next否则就跳转到登录页面
```

​				：Vue动态路由

```
场景：详情页(文章、商品)
router.js配置：
	{
    path: "/list",
    name: "List",
    children:[
      {
        path:"/list/:id",
        name:'Details',
        component: () =>
          import("../views/Details.vue"),
      }
    ],
    component: () =>
      import("../views/List.vue"),
  },
```

​				：双向绑定原理
Vue.js 的双向绑定原理主要是基于发布者-订阅者模式（也可以认为是观察者模式）和数据劫持技术实现的，核心是 Object.defineProperty() 方法。Vue.js 通过这个方法可以劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

以下是双向绑定的简化原理：

数据劫持：Vue.js 通过 Object.defineProperty() 方法将组件的 data 对象中的所有属性转化为 getter 和 setter，Vue.js 的核心响应式系统能够监听数据的变化。当数据发生变动时，setter 会被触发。

依赖收集：在 Vue 组件初始化渲染时，会对模板中的变量进行依赖收集。如果模板中有数据绑定，这些数据（即响应式属性）就会将对应的视图作为订阅者收集到自己的订阅者列表中。

指令解析：Vue.js 编译模板时，对于模板中的 v-model 这类需要实现双向绑定的指令，会特别处理，确保数据变化时更新视图，视图变化（如用户输入）时也能更新数据。

视图更新：当数据发生变化时，setter 会通知所有订阅者（也就是依赖），触发它们的更新函数，以确保它们对应的视图能够实时更新。

用户输入更新数据：对于用户输入（如文本框的 input 事件），Vue.js 会更新相关数据，这个过程是双向绑定的“反向”部分，即视图对数据的更新。

总结来说，Vue 的双向绑定是通过数据劫持结合发布者-订阅者模式的方式，让数据变化时更新视图，同时更新视图时能自动更新数据，从而实现了双向绑定。
​				：什么是虚拟DOM
虚拟DOM（Virtual DOM）是一个编程概念，其中UI的表示形式保持在内存中，并通过某些库（如React或Vue.js）与“实际”的DOM（Document Object Model）同步。这个过程称为调和（Reconciliation）。

虚拟DOM作为一个轻量级的JavaScript对象，是真实DOM的一个抽象表示。当应用的状态变化时，虚拟DOM提供了一种更高效的方法来更新视图，而不是直接操作昂贵的DOM操作。

虚拟DOM的工作流程通常如下：

1. **初始渲染**：应用的状态首次渲染时，虚拟DOM会转换成实际的DOM，然后在浏览器中呈现。

2. **状态变更**：当应用状态发生变化时，这个变化会转换成新的虚拟DOM树。

3. **差异比较**：新的虚拟DOM树会与上一次的虚拟DOM树进行比较，这个过程称为Diff算法，用来计算出实际需要进行更新的部分。

4. **更新视图**：一旦计算出差异，这些差异会应用到真实的DOM上，这个步骤称为补丁（Patching）或者更新（Update）。

使用虚拟DOM的优势在于：

- **性能提升**：虚拟DOM减少了直接操作DOM的次数，因为直接操作DOM是非常昂贵的。通过聚合多次状态变更导致的DOM变更，然后一次性进行更新，可以显著提高应用性能。
- **跨平台**：虚拟DOM由于是JavaScript对象，可以在浏览器之外的环境运行，如服务器或移动应用，这使得同一套代码可以跨平台运行。
- **简化编程模型**：开发者可以像操作普通JavaScript对象一样操作虚拟DOM，而不用担心具体的DOM操作细节，简化了开发过程。
diff算法
Vue.js 使用虚拟DOM和Diff算法来更新视图。Diff算法是一种高效的算法，用于比较两棵树（在这里指的是虚拟DOM树）的差异，并且只更新那些实际发生变化的部分。Vue的Diff算法主要关注于同级别的节点比较，而不是跨级别比较，这样可以提高比较的效率。

Vue的Diff算法的基本步骤如下：

1. **同级比较**：Diff算法只会在同一层级的节点进行比较，如果一个节点在旧树中存在而在新树中不存在，那么这个节点将被移除；如果新树中有新加入的节点，那么这个节点将被创建。

2. **节点标记**：Vue为每个节点提供了一个唯一的key属性，这个key用于识别这个节点是否可以复用。在比较过程中，带有相同key的节点会被认为是同一节点，这样可以优化节点的重新排列。

3. **节点比较**：当比较两个节点时，首先会比较节点的类型。如果节点类型不同，那么旧节点将被移除，并创建新节点替换它。如果节点类型相同，那么会比较节点的属性和子节点。

4. **更新子节点**：当比较子节点时，Vue使用了一个双端比较的策略。它会同时从旧节点和新节点的两端开始比较，识别出可以复用的节点，减少不必要的节点创建和移除操作。

5. **列表对比优化**：在处理列表时，Vue会尝试最大限度地复用节点。通过使用key属性，Vue可以识别出列表中哪些子节点可以保留，哪些需要移动。

总的来说，Vue的Diff算法通过智能的节点比较和高效的更新策略，最小化了DOM操作，从而提高了应用的性能。
讲一下MVVM
MVVM是Model-View-ViewModel的缩写，它是一种设计模式，用于分离用户界面（UI）的表示层和业务逻辑层。这种模式主要用于图形用户界面（GUI）的开发。在MVVM模式中，View负责显示，Model代表数据，ViewModel作为View和Model之间的桥梁，处理逻辑并提供数据绑定。

1. **Model（模型）**：代表应用程序的数据逻辑。它直接管理数据、逻辑和规则，并不涉及任何与表示层相关的信息。

2. **View（视图）**：是用户界面的组成部分，负责展示数据（即Model）并触发用户交互事件。视图是被动的，它不直接修改Model，而是通过与ViewModel交互来显示或收集数据。

3. **ViewModel（视图模型）**：是View和Model之间的连接。ViewModel监听Model中数据的变化，并处理View中用户的命令（如按钮点击）。ViewModel通过数据绑定将Model的信息传递给View，同时也将View的指令转换为Model的更新。

MVVM的关键特点是数据绑定，这意味着ViewModel中的数据变化会自动更新到View中，而用户在View上的操作也会自动反映到ViewModel和Model上。这种自动同步减少了大量的手动DOM操作和事件处理代码，使得开发者可以专注于业务逻辑，而不是与DOM的交互。

MVVM模式在现代前端框架中非常流行，如Angular、Vue.js和Knockout等。这些框架提供了实现MVVM的工具和库，使得开发者可以更容易地构建和维护复杂的用户界面。

​		3.2 微信小程序

​				：如何自定义头部？
在微信小程序中，自定义页面的头部可以通过以下步骤实现：

1. **关闭默认导航栏**：在小程序的页面配置文件（`.json`）中，将`navigationStyle`设置为`custom`来关闭默认的导航栏。例如，在`pages/index/index.json`中添加如下配置：

```json
{
  "navigationStyle": "custom"
}
```

2. **创建自定义导航栏**：在页面的`.wxml`文件中，创建一个自定义的导航栏区域。你可以使用`view`组件来布局导航栏，并使用样式来设计外观。

```html
<!-- pages/index/index.wxml -->
<view class="custom-navbar">
  <view class="navbar-left">返回</view>
  <view class="navbar-title">页面标题</view>
  <view class="navbar-right">更多</view>
</view>
<!-- 页面的其他内容 -->
```

3. **添加样式**：在页面的`.wxss`文件中，添加相应的CSS样式来设计自定义导航栏的外观。

```css
/* pages/index/index.wxss */
.custom-navbar {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background-color: #1AAD19;
  color: white;
}

.navbar-left, .navbar-right {
  /* 样式代码 */
}

.navbar-title {
  /* 样式代码 */
}
```

4. **适配状态栏高度**：由于不同设备的状态栏高度可能不同，你可能需要在自定义导航栏中适配状态栏的高度。可以在页面的`.js`文件中获取系统信息，并将状态栏的高度设置为自定义导航栏的`padding-top`。

```javascript
// pages/index/index.js
Page({
  data: {
    statusBarHeight: 0
  },
  onLoad: function() {
    const { statusBarHeight } = wx.getSystemInfoSync();
    this.setData({ statusBarHeight });
  }
});
```

然后在`.wxml`文件中使用内联样式或者类绑定来设置自定义导航栏的顶部内边距。

```html
<view class="custom-navbar" style="padding-top:{{statusBarHeight}}px;">
  <!-- 导航栏内容 -->
</view>
```

通过这些步骤，你可以创建一个自定义的头部导航栏，使其适应不同的设备和设计需求。
​				：如何自定义底部？
在微信小程序中，自定义底部通常指的是自定义底部 TabBar。微信小程序提供了一个默认的底部 TabBar，但如果你想要完全自定义它的样式和行为，你可以隐藏默认的 TabBar 并在页面上添加自定义的组件来实现。以下是自定义底部 TabBar 的步骤：

隐藏默认 TabBar：在小程序的全局配置文件 app.json 中，设置 tabBar 的 custom 字段为 true。
{
  "tabBar": {
    "custom": true,
    // 其他 tabBar 配置...
  }
  // 其他全局配置...
}
创建自定义 TabBar 组件：在小程序的目录中创建一个自定义组件，例如 custom-tab-bar。
/custom-tab-bar/custom-tab-bar.js
/custom-tab-bar/custom-tab-bar.json
/custom-tab-bar/custom-tab-bar.wxml
/custom-tab-bar/custom-tab-bar.wxss
编写自定义 TabBar 组件的代码：在 custom-tab-bar 组件的 .wxml 文件中，编写你的自定义 TabBar 的 HTML 结构。
​		3.3 uni-app

​				：生命周期
uni-app 的生命周期主要分为应用生命周期和页面生命周期。

应用生命周期包括：
1. `onLaunch`：当uni-app初始化完成时触发（全局只触发一次）。
2. `onShow`：当uni-app启动，或从后台进入前台显示时触发。
3. `onHide`：当uni-app从前台进入后台时触发。
4. `onError`：当uni-app脚本错误或 API 调用失败时触发。
5. `onPageNotFound`：当页面无法打开时触发。
6. `onThemeChange`：当系统主题变化时触发。
7. `onUnhandledRejection`：当Promise被reject且没有绑定错误处理器时触发。

页面生命周期包括：
1. `onLoad`：监听页面加载，一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数。
2. `onShow`：监听页面显示，每次打开页面都会调用。
3. `onReady`：监听页面初次渲染完成，一个页面只会调用一次。
4. `onHide`：监听页面隐藏，当navigateTo或底部tab切换时调用。
5. `onUnload`：监听页面卸载，当redirectTo或navigateBack的时候调用。
6. `onPullDownRefresh`：监听用户下拉刷新事件。
7. `onReachBottom`：页面上拉触底事件的处理函数。
8. `onShareAppMessage`：用户点击右上角分享。
9. `onPageScroll`：监听页面滚动。
10. `onResize`：监听页面尺寸改变。
11. `onTabItemTap`：当点击tab时触发。

注意，具体的生命周期函数可能会随着uni-app框架的更新而有所变化，建议查阅最新的官方文档以获取最准确的信息。
​				：条件编译
uni-app 支持条件编译，允许开发者针对不同的平台编写特定的代码。条件编译可以应用于 JavaScript、Vue 模板以及 App 和页面的配置文件中。

以下是一些常用的条件编译语法：

1. JavaScript 条件编译：

```javascript
// #ifdef 平台标识
console.log('这段代码只会在特定平台编译执行');
// #endif

// #ifndef 平台标识
console.log('这段代码在特定平台之外编译执行');
// #endif
```

2. Vue 模板条件编译：

```html
<!-- #ifdef 平台标识 -->
<p>这段代码只会在特定平台编译执行</p>
<!-- #endif -->

<!-- #ifndef 平台标识 -->
<p>这段代码在特定平台之外编译执行</p>
<!-- #endif -->
```

3. App 和页面配置文件条件编译：

```json
// pages.json
{
  "pages": [
    // #ifdef H5
    {
      "path": "path-for-h5-only",
      "style": {}
    },
    // #endif
    // #ifndef H5
    {
      "path": "path-for-non-h5",
      "style": {}
    }
    // #endif
  ]
}
```

平台标识可以是以下之一：

- `APP-PLUS`：表示5+App（包括iOS和Android）
- `H5`：表示Web平台（浏览器）
- `MP-WEIXIN`：表示微信小程序
- `MP-ALIPAY`：表示支付宝小程序
- `MP-BAIDU`：表示百度小程序
- `MP-TOUTIAO`：表示字节跳动小程序
- `MP-QQ`：表示QQ小程序
- `MP-360`：表示360小程序
- `QUICKAPP-WEBVIEW`：表示快应用通用（包括联盟和华为）
- `QUICKAPP-WEBVIEW-UNION`：表示快应用联盟
- `QUICKAPP-WEBVIEW-HUAWEI`：表示快应用华为

使用条件编译时，需要确保编译指令的正确性，否则可能导致编译错误或者运行时错误。更多详细信息和平台标识，请参考最新的 uni-app 官方文档。

第四章 性能优化篇

​		这些优化策略通常指的是在开发Web应用或移动应用时，如何提高性能和用户体验。以下是每个部分的简要概述：

4.1 加载优化：
- 减少资源体积：压缩JavaScript、CSS和图片文件。
- 使用CDN：通过内容分发网络加快资源加载速度。
- 懒加载：延迟加载非关键资源，如下方图片、列表等。
- 异步加载：使用异步脚本加载方式，避免阻塞渲染。
- 缓存策略：合理设置HTTP缓存，减少重复资源请求。

4.2 图片优化：
- 格式选择：使用WebP、JPEG XR等现代格式减少图片体积。
- 响应式图片：根据设备分辨率提供合适大小的图片。
- 图片压缩：在不影响质量的前提下减少图片文件大小。
- 图片懒加载：仅当图片进入可视区域时才加载。
- 使用精灵图：合并多个小图标到一张图片中减少HTTP请求。

4.3 渲染优化：
- 减少DOM操作：批量操作DOM或使用虚拟DOM减少重绘和回流。
- 使用CSS动画：利用硬件加速的CSS动画代替JavaScript动画。
- 避免长时间运行的JavaScript任务：使用Web Workers处理复杂计算。
- 使用请求动画帧（requestAnimationFrame）：进行动画渲染。

4.4 首屏优化：
- 关键CSS内联：将首屏必要的CSS样式内联在HTML中。
- 服务端渲染（SSR）：提前在服务器生成HTML，加快首屏显示。
- 分割代码：使用代码分割技术，仅加载首屏需要的JavaScript和CSS。
- 优先加载关键资源：使用preload和prefetch指令优先加载关键资源。

4.5 Vue优化：
- 组件懒加载：使用Vue的异步组件和Webpack的动态import语法。
- 优化v-for：避免使用v-for和v-if在同一个元素上，为列表项设置唯一的key值。
- 计算属性和监听器：合理使用computed和watch来处理数据变化。
- 虚拟滚动：对于大量数据的列表，使用虚拟滚动只渲染可视部分。
- 事件处理：使用事件代理，减少事件监听器数量。

这些优化措施需要根据实际项目的需求和性能瓶颈来选择性地应用。在实施优化时，应当通过性能分析工具来识别问题，并验证优化效果。

第五章 兼容篇

​	5.1 页面样式兼容：
页面样式兼容主要指的是确保网页在不同浏览器和设备上能够保持一致的外观和体验。为了实现样式兼容，可以采取以下措施：

- 使用CSS重置（Reset CSS）或规范化（Normalize CSS）来统一不同浏览器的默认样式。
- 利用前缀写法（如`-webkit-`, `-moz-`, `-o-`, `-ms-`）来确保CSS3属性在不同浏览器中的兼容性。
- 使用功能检测库（如Modernizr）来检测浏览器对某些CSS特性的支持情况，并根据检测结果应用回退样式。
- 采用响应式设计（Responsive Design）确保页面在不同屏幕尺寸和分辨率下的适应性。
- 使用CSS框架（如Bootstrap）来帮助处理跨浏览器的样式兼容问题。
- 进行跨浏览器测试，确保在主流浏览器和设备上都能正常显示。

5.2 框架兼容：
框架兼容通常指的是确保前端框架（如Vue.js、React、Angular等）能够在不同的环境中正常工作。以下是一些确保框架兼容性的措施：

- 遵循框架的官方指南和最佳实践，使用框架支持的特性和API。
- 使用Babel等转译器将现代JavaScript代码转换为广泛支持的ES5代码，以确保在旧版浏览器中也能运行。
- 使用Polyfill来模拟旧浏览器中缺失的现代Web API功能。
- 避免使用框架的实验性或非标准特性，因为这些特性可能在不同的环境中表现不一致。
- 对框架进行适当的配置，以支持不同的目标环境，例如通过Webpack的配置来指定目标浏览器。
- 定期更新框架和依赖库，以利用最新的兼容性改进和bug修复。
- 进行全面的测试，包括单元测试、集成测试和端到端测试，确保应用在不同环境中的稳定性。

总的来说，页面样式兼容和框架兼容都需要开发者在编码、测试和部署阶段持续关注，以确保最终用户无论在何种设备或浏览器上都能获得良好的体验。

第六章 网络请求篇

6.1 跨域：
跨域（Cross-Origin）是指浏览器出于安全考虑实施的同源策略（Same-Origin Policy），不允许一个域下的文档或脚本与另一个域下的资源进行交互。要解决跨域问题，常用的方法有：

- JSONP：通过`<script>`标签的src属性绕过同源策略，仅支持GET请求。
- CORS（跨源资源共享）：服务器设置`Access-Control-Allow-Origin`等HTTP响应头来允许特定的外部域访问资源。
- 代理服务器：在服务器端设置代理，接收客户端请求并转发到目标服务器，然后将响应返回给客户端。
- document.domain：将不同子域的document.domain设置为相同的主域，实现跨子域通信。
- postMessage：HTML5提供的API，允许不同源之间的窗口进行通信。
- WebSockets：提供了在单个TCP连接上进行全双工通讯的协议，不受同源策略限制。

6.2 HTTP和HTTPS：
HTTP（超文本传输协议）和HTTPS（安全超文本传输协议）是两种网络传输协议。

- HTTP：是一种不安全的协议，数据在传输过程中以明文形式传送，容易被截取和篡改。
- HTTPS：是HTTP的安全版本，通过SSL/TLS协议提供数据加密、数据完整性验证和身份验证，保证了数据传输的安全性。

HTTPS相比HTTP的优势包括：

- 加密：防止数据在传输过程中被窃听和篡改。
- 身份验证：确保用户访问的网站是服务器提供的真实网站。
- 数据完整性：验证数据在传输过程中未被篡改。

随着网络安全意识的提高，越来越多的网站和应用转向使用HTTPS协议。搜索引擎如Google也倾向于对HTTPS网站给予更高的排名。此外，某些新的Web功能（如地理位置API、Service Workers等）只能在HTTPS环境下使用。

第七章 WEB安全篇

​	7.1 XSS攻击：
XSS（跨站脚本攻击，Cross-Site Scripting）是一种常见的网络安全漏洞，攻击者通过在目标网站上注入恶意脚本，当其他用户浏览该网站时执行这些脚本，从而窃取用户信息或进行其他恶意操作。防御措施包括：
- 对用户输入进行验证和转义，避免直接插入HTML、JavaScript等代码。
- 使用CSP（内容安全策略）限制资源加载和执行。
- 设置HTTPOnly属性，防止JavaScript访问Cookie。

7.2 SQL注入：
SQL注入是攻击者通过将SQL命令插入到Web表单提交或页面请求的查询字符串，从而欺骗服务器执行恶意的SQL命令。防御措施包括：
- 使用参数化查询或预编译语句，避免直接将用户输入拼接到SQL语句中。
- 对用户输入进行严格的验证。
- 限制数据库权限，确保Web应用使用的数据库账户只具有必要的权限。

7.3 接口安全：
接口（API）安全是指保护网络接口不受到未授权访问和攻击。防御措施包括：
- 使用OAuth、JWT等认证机制对用户和第三方应用进行身份验证。
- 对数据进行加密传输，使用HTTPS协议。
- 对API访问进行限制，如通过API网关实施速率限制和IP黑名单。

7.4 CSRF攻击（XSRF）：
CSRF（跨站请求伪造，Cross-Site Request Forgery）攻击是指攻击者诱导用户在已认证的状态下，向Web应用发送非预期的请求。防御措施包括：
- 使用Anti-CSRF Token，确保请求是由用户意愿发起的。
- 对于敏感操作使用双重验证，如重新输入密码或发送验证码。
- 设置SameSite属性的Cookie，限制第三方网站发起的请求。

以上安全问题的防御措施都是为了减少或消除安全风险，保护用户数据和系统安全。开发者应该在设计和开发阶段就考虑这些安全措施，并进行定期的安全审计和测试。
第八章 其他类

​		8.1 Token：
Token是一种安全机制，用于在客户端和服务器之间传递验证信息。在用户登录后，服务器会生成一个Token并返回给客户端，客户端后续的请求都会携带这个Token，服务器通过验证Token来确认用户的身份。Token常用于无状态的认证机制，如RESTful API的安全通信。

8.2 SEO：
SEO（搜索引擎优化，Search Engine Optimization）是一系列优化网站的方法和技术，目的是提高网站在搜索引擎中的排名，从而吸引更多的访问者。SEO包括关键词优化、内容质量提升、网站结构优化、提高页面加载速度、建立反向链接、使用合适的meta标签等策略。

8.3 JWT认证：
JWT（JSON Web Tokens）是一种开放标准（RFC 7519），用于在网络应用环境间传递声明（claim）。JWT通常用于身份验证和信息交换，它允许在双方之间传递安全可靠的信息。JWT包含三部分：头部（Header）、载荷（Payload）和签名（Signature）。头部通常包含令牌的类型和加密算法；载荷包含声明信息；签名用于验证消息的真实性和完整性。使用JWT的好处包括自包含、易于传输和跨语言支持。

ç
        JSON Web Token 通过JSON形式作为在web应用中的令牌，可以在各方之间安全的把信息作为JSON对象传输
        信息传输、授权
        JWT的认证流程
        1.前端把账号密码发送给后端的接口
        2.后端核对账号密码成功后，把用户id等其他信息作为JWT 负载，把它和头部分别进行base64编码拼接后签名，形成一个JWT（token）。
        3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内
        4.后端检查是否存在，如果存在就验证JWT的有效性（签名是否正确，token是否过期）
        5.验证通过后后端使用JWT中包含的用户信息进行其他的操作，并返回对应结果
        简洁、包含性、因为Token是JSON加密的形式保存在客户端，所以JWT是跨语言的，原则上是任何web形式都支持。


jwt认证过期如何做到无感知刷新



		JWT认证过期的无感知刷新通常涉及到使用两个令牌：访问令牌（Access Token）和刷新令牌（Refresh Token）。访问令牌具有较短的有效期，而刷新令牌具有较长的有效期。当访问令牌过期时，可以使用刷新令牌来获取新的访问令牌，而用户无需重新登录。以下是实现无感知刷新的一种常见流程：

1. 用户使用用户名和密码登录。
2. 服务器验证用户凭据，发放访问令牌和刷新令牌。
3. 用户访问需要认证的资源时，携带访问令牌。
4. 服务器验证访问令牌，如果有效，则允许用户访问资源。
5. 当访问令牌即将过期或已过期时，客户端会自动使用刷新令牌向认证服务器请求新的访问令牌。
6. 服务器验证刷新令牌，如果有效，发放新的访问令牌。
7. 客户端使用新的访问令牌继续访问资源。

在客户端实现时，可以通过拦截器（interceptor）来检查每个请求的响应状态。如果检测到访问令牌过期的错误（例如，HTTP 401 Unauthorized），则自动发送刷新令牌请求。如果刷新令牌请求成功，更新本地存储的访问令牌，并重试原始请求。这样用户就不会感知到令牌的刷新过程。

需要注意的是，刷新令牌的安全性至关重要，因为它可以用来获取新的访问令牌。因此，刷新令牌的存储和传输需要特别小心，以防止泄露。此外，服务器端也应该实现相应的逻辑来处理刷新令牌的失效和替换。


# 新增vue2/vue3

1. vue2双向绑定和vue3双向绑定区别
Vue 2中的双向绑定是通过v-model指令实现的，它将数据的变化反映到视图上，并且将用户输入的变化反映回数据。但是在Vue 2中，v-model只能用于表单元素，对于自定义组件需要手动实现双向绑定。

而在Vue 3中，双向绑定的实现方式有所不同。Vue 3中引入了新的API，如`v-model`指令的底层实现已经改变，可以更灵活地应用于自定义组件，并且支持自定义的双向绑定行为。Vue 3中的双向绑定更加强大和灵活。
2. 说一说vue2和vue3区别
Vue 3相对于Vue 2来说有一些重要的变化和改进：

性能优化：Vue 3在性能方面有了显著的改进，包括更快的渲染速度、更小的包大小和更高效的虚拟DOM算法。

Vue 3在性能方面进行了多方面的优化，其中最显著的改进是在虚拟DOM的处理上。Vue 3引入了静态树提升（Static Tree Hoisting）和一些其他优化，使得渲染速度得到了显著提升。这意味着在更新视图时，Vue 3能够更快地识别出哪些部分是静态的，从而减少了不必要的DOM操作，提高了整体的渲染性能。
举例来说，假设在Vue 2中，一个组件的模板中包含了大量静态内容和动态内容，每次更新时都需要重新计算整个模板。而在Vue 3中，通过静态树提升的优化，Vue 能够在编译阶段识别出哪些部分是静态的，从而在更新时只需要关注动态部分，大大减少了不必要的计算和操作，提高了性能。

Composition API：Vue 3引入了Composition API，它提供了一种新的组织组件逻辑的方式，使得代码更加清晰和可维护。

举例来说，假设在Vue 2中，一个组件的逻辑代码包含了大量的数据、计算属性、方法和生命周期钩子，随着组件逻辑的复杂度增加，代码变得难以维护。而在Vue 3中，通过使用Composition API，可以将相关的数据、计算属性和方法组织在一起，使得代码更加清晰和易于管理。例如，可以将数据相关的逻辑放在一个useData函数中，将计算属性相关的逻辑放在一个useComputed函数中，这样可以更好地组织和重用逻辑代码。

TypeScript支持：Vue 3对TypeScript的支持更加友好，包括更好的类型推断和更完善的类型定义。

更好的Tree-shaking：Vue 3通过使用ES模块来提供更好的Tree-shaking支持，可以更有效地减小打包后的文件大小。

更好的响应式系统：Vue 3中的响应式系统进行了重写，使得它更加高效和可靠。

总的来说，Vue 3在性能、开发体验和可维护性等方面都有了很大的改进，是一个更加强大和现代化的前端框架。


3. 在beforeMount中如何获取dom 
	在Vue 2中，在`beforeMount`生命周期钩子中获取DOM元素可以通过`this.$el`来实现。`this.$el`指向Vue实例所管理的根DOM元素，因此在`beforeMount`生命周期钩子中可以通过`this.$el`来获取根DOM元素。

```javascript
beforeMount() {
  const rootElement = this.$el;
  // 在beforeMount生命周期钩子中可以通过this.$el来获取DOM元素
  console.log(rootElement);
}
```

需要注意的是，在`beforeMount`生命周期钩子中获取的DOM元素可能还没有被挂载到页面上，因此对DOM元素的操作可能会受到限制。如果需要在DOM元素挂载后进行操作，可以考虑在`mounted`生命周期钩子中进行。
4. nextTick原理
   nextTick是Vue中的一个异步更新队列的机制，它可以让我们在DOM更新之后执行一些操作。其原理是利用JavaScript的事件循环机制，在当前代码执行完成后，将回调函数推入微任务队列中，等待当前任务执行完成后立即执行。

具体来说，当我们调用this.$nextTick(callback)时，Vue会将callback函数推入微任务队列中，等待当前任务执行完成后立即执行。这样可以确保callback函数在DOM更新之后执行，从而能够获取到最新的DOM状态。

这种机制可以用于在DOM更新后执行一些操作，比如获取更新后的DOM尺寸、操作更新后的DOM元素等。这样可以避免在DOM更新之前执行这些操作时获取到的是旧的DOM状态。
5. Vite使用过吗？说一说Vite与webpack区别
   Vite是一个基于ES模块的快速开发工具，它专注于提供快速的冷启动、热模块替换（HMR）和快速的生产构建。Vite使用原生ES模块（ES Module）作为开发时的模块系统，利用现代浏览器对ES模块的原生支持，从而实现了快速的冷启动和热模块替换。

相比之下，Webpack是一个功能强大的打包工具，它支持各种类型的模块（CommonJS、AMD、ES Module等），并且具有丰富的插件系统和loader系统，可以处理各种复杂的场景和需求。

Vite与Webpack的区别主要体现在以下几个方面：
1. 冷启动速度：Vite利用ES模块的特性，实现了快速的冷启动，而Webpack在处理大型项目时，冷启动速度可能会比较慢。
2. 开发环境下的热模块替换（HMR）：Vite通过ES模块的热更新特性，直接替换，实现了更快速的热模块替换，而Webpack的HMR可能会相对慢一些。
3. 生产构建：Webpack在处理复杂的生产构建时具有更多的功能和插件支持，可以处理各种复杂的需求，而Vite更专注于提供快速的开发体验。

总的来说，Vite更适合于快速的开发体验和小型项目，而Webpack更适合于处理复杂的生产构建和大型项目。

Webpack的热模块替换（Hot Module Replacement，HMR）功能是通过一系列机制来实现的：

HMR Runtime：Webpack会在构建过程中生成用于热更新的运行时代码，这部分代码负责在客户端与服务器端之间建立WebSocket连接，用于传输更新的模块代码。

HMR 插件：在Webpack配置中，需要使用webpack.HotModuleReplacementPlugin插件来启用HMR功能。这个插件会负责在运行时处理模块的热替换逻辑。

客户端更新：当某个模块发生变化时，Webpack会通过WebSocket将更新的模块代码推送到客户端。客户端接收到更新后会根据新的模块代码进行局部更新，从而实现页面的实时更新。

模块标识：为了实现模块的热替换，Webpack会给每个模块分配一个唯一的标识符，用于在运行时进行模块的匹配和替换。
6. pinia使用过吗？说一说vuex与pinia区别
   Pinia是一个基于Vue 3的状态管理库，它提供了一种简单、直观的方式来管理应用的状态。与之相比，Vuex是Vue官方推荐的状态管理库，用于在Vue应用中集中管理状态。

以下是Vuex和Pinia之间的一些区别：

1. 基于Vue版本：Vuex是为Vue 2设计的，而Pinia是为Vue 3设计的。因此，如果你的项目是基于Vue 3的，Pinia可能是更好的选择。

2. API 设计：Pinia的API设计更加简单和直观，它采用了类似于Vue 3的Composition API的风格，使得状态管理的逻辑更加清晰和灵活。而Vuex则采用了基于对象的API设计，需要在actions、mutations和getters之间进行切换，相对而言可能更加繁琐。

3. TypeScript 支持：Pinia对TypeScript的支持更加友好，它能够更好地与TypeScript结合使用，提供更好的类型推断和类型安全。而Vuex在Vue 2中对TypeScript的支持相对较弱。

4. 性能：Pinia在性能方面进行了优化，它采用了更加轻量级的实现方式，因此在一些场景下可能会有更好的性能表现。

总的来说，Pinia相对于Vuex来说更加适合于Vue 3项目，它提供了更简单、直观的API设计，更好的TypeScript支持以及更好的性能表现。如果你的项目是基于Vue 3的，可以考虑使用Pinia来管理应用的状态。
7. vue如何解决seo的问题
   Vue解决SEO（Search Engine Optimization，搜索引擎优化）问题的主要方法是使用服务端渲染（SSR）或预渲染技术。

服务端渲染（SSR）：Vue提供了服务端渲染的能力，可以在服务器端将Vue组件渲染成HTML字符串，然后将其发送给浏览器。这样搜索引擎爬虫在抓取页面时能够获取到完整的HTML内容，从而更好地理解页面的内容和结构。

预渲染：除了SSR，Vue还可以使用预渲染技术来解决SEO问题。预渲染是指在构建时生成静态HTML文件，这些文件包含了预先渲染的Vue组件，可以直接被搜索引擎爬虫抓取。预渲染的HTML文件可以直接提供给搜索引擎爬虫，从而改善页面的搜索引擎友好性。

通过使用服务端渲染或预渲染技术，Vue能够更好地满足搜索引擎爬虫的需求，从而提高页面在搜索引擎中的排名和曝光度。同时，合理的页面结构、语义化的HTML标记、良好的内容质量等也是提高SEO的重要因素，Vue开发者需要在这些方面进行合理的优化。
8. vue如何分包
在Vue中，可以通过webpack的代码分割功能来实现分包。代码分割可以将应用程序代码分割成多个文件，从而实现按需加载，减小初始加载体积，提高页面加载速度。

在Vue项目中，可以使用以下方式进行代码分割：

1. 使用动态导入（Dynamic Import）：在需要分割的地方使用动态导入语法，例如`import()`，Webpack会将动态导入的模块单独打包成一个文件，从而实现分包。

```javascript
const module = () => import('./module.vue');
```

2. 使用Webpack的`optimization.splitChunks`配置：在Webpack配置中，可以通过`optimization.splitChunks`配置来对代码进行分割，将公共模块、第三方库等抽离成单独的文件。

```javascript
module.exports = {
  // ...
  optimization: {
    splitChunks: {
      chunks: 'all',
    },
  },
};
```

通过以上方式，可以实现Vue应用的代码分割，将应用程序代码分割成多个文件，从而实现按需加载，减小初始加载体积，提高页面加载速度。


9.  Vue3自己封装过组件吗？如何设计一个modal组件
是的，我有经验封装Vue 3组件。设计一个modal组件的一般步骤如下：

1. Props：确定modal组件需要的props，例如visible（控制modal显示与隐藏）、title（标题）、content（内容）等。

2. 插槽（Slots）：考虑modal组件的插槽设计，例如插槽可以用于自定义标题、自定义内容、自定义底部按钮等。

3. 状态管理：在组件内部管理modal的显示与隐藏状态，可以使用响应式的`ref`或`reactive`来管理状态。

4. 事件处理：处理modal组件内部的事件，例如点击确认按钮、取消按钮等。

5. 动画效果：考虑是否需要为modal组件添加动画效果，例如淡入淡出、从底部弹出等。

6. 样式设计：设计modal组件的样式，包括遮罩层样式、modal框样式等。

7. 全局注册：最后将modal组件进行全局注册，以便在应用的任何地方使用。

以下是一个简单的modal组件的示例代码：

```vue
<template>
  <div v-if="visible" class="modal">
    <div class="modal-dialog">
      <div class="modal-header">
        <slot name="title">Default Title</slot>
      </div>
      <div class="modal-content">
        <slot name="content">Default Content</slot>
      </div>
      <div class="modal-footer">
        <button @click="handleCancel">Cancel</button>
        <button @click="handleOk">OK</button>
      </div>
    </div>
  </div>
</template>

<script>
import { ref } from 'vue';

export default {
  props: {
    visible: {
      type: Boolean,
      default: false,
    },
  },
  setup(props, { emit }) {
    const handleCancel = () => {
      emit('update:visible', false);
    };

    const handleOk = () => {
      // 处理确认按钮点击事件
    };

    return {
      handleCancel,
      handleOk,
    };
  },
};
</script>

<style>
/* 样式设计 */
</style>
```

这是一个简单的modal组件示例，其中包括props、插槽、状态管理、事件处理等基本设计。根据实际需求，可以进一步扩展和优化modal组件的功能和设计。
10. vue3提升性能有哪些点
Vue 3 在性能方面进行了多方面的优化，以下是一些主要的性能优化点：

1. 更快的渲染：Vue 3 使用了重写的响应式系统，使得渲染性能得到了显著提升。Vue 3 的虚拟 DOM 算法也经过优化，使得页面渲染速度更快。

2. 更小的包大小：Vue 3 的核心库经过精简和优化，使得打包后的文件大小更小，从而减少了页面加载时间。

3. 更好的 Tree-shaking：Vue 3 通过使用 ES 模块来提供更好的 Tree-shaking 支持，可以更有效地减小打包后的文件大小，去除未使用的代码。

4. 静态树提升（Static Tree Hoisting）：Vue 3 引入了静态树提升的优化，能够在编译阶段识别出哪些部分是静态的，从而在更新时只需要关注动态部分，减少了不必要的计算和操作，提高了性能。

5. 更好的 TypeScript 支持：Vue 3 对 TypeScript 的支持更加友好，包括更好的类型推断和更完善的类型定义，使得开发者能够更轻松地使用 TypeScript 进行开发，并且能够在编译阶段发现更多的错误。

总的来说，Vue 3 在性能方面进行了多方面的优化，包括更快的渲染速度、更小的包大小、更好的 Tree-shaking 支持、静态树提升和更好的 TypeScript 支持等，使得 Vue 3 在性能方面有了显著的改进。
1.  Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
   Vue 3.0 引入的 Composition API 与 Vue 2.x 中的 Options API 在组件代码组织和逻辑复用方面有显著的区别：

1. 代码组织方式：
   - Options API：在 Vue 2.x 中，组件的逻辑是按照选项（如 `data`, `methods`, `computed`, `watch` 等）组织的。这意味着相关的代码可能会分散在不同的选项中，使得组件逻辑分散且难以维护，尤其是在大型组件中。
   - Composition API：在 Vue 3.0 中，Composition API 允许开发者按照逻辑关注点来组织代码，而不是按照选项类型。这是通过 `setup` 函数实现的，它是一个新的组件选项，允许开发者在一个地方使用组合式函数来组织和复用逻辑。

2. 逻辑复用：
   - Options API：在 Vue 2.x 中，逻辑复用通常依赖于 mixins。然而，mixins 可能会导致命名冲突和来源不明确的问题，使得组件难以维护。
   - Composition API：Vue 3.0 的 Composition API 通过可组合的函数（composable functions）来实现逻辑复用。这些函数可以封装并导出可重用的逻辑，然后在其他组件的 `setup` 函数中导入和使用，从而避免了 mixins 的问题。

3. 类型推断：
   - Options API：在 Vue 2.x 中，由于选项对象的动态特性，TypeScript 的类型推断并不总是有效，这可能导致类型系统的一些限制。
   - Composition API：Vue 3.0 的 Composition API 更加友好地支持 TypeScript，因为 `setup` 函数和可组合的函数可以很容易地利用 TypeScript 的类型推断和注解。

4. 响应式引用：
   - Options API：在 Vue 2.x 中，`data` 选项自动将其返回的对象转换为响应式状态。
   - Composition API：在 Vue 3.0 中，需要使用 `ref` 和 `reactive` 等函数来显式地创建响应式引用和响应式对象。

总的来说，Composition API 提供了更灵活的代码组织方式，更好的逻辑复用能力，以及更强的 TypeScript 支持，这些特性使得它在构建大型或复杂应用时更具优势。然而，Options API 仍然是一个有效且易于上手的 API，对于许多简单的场景来说可能更加直观。

2.  Proxy 相对于 Object.defineProperty 有哪些优点？
   `Proxy` 相对于 `Object.defineProperty` 有以下几个优点：

1. 拦截能力：`Proxy` 可以拦截更多的对象操作，包括属性读取、属性赋值、属性枚举、函数调用等几乎所有对象操作，而 `Object.defineProperty` 只能拦截属性的读取和赋值。

2. 动态性：`Proxy` 不需要事先知道目标对象的结构，可以动态地拦截对对象的任何操作，而 `Object.defineProperty` 需要在对象上显式地定义每个属性。

3. 默认行为：`Proxy` 提供了默认行为的实现，开发者可以选择性地覆盖或扩展这些行为，而 `Object.defineProperty` 需要手动实现所有的行为。

4. 性能：虽然 `Proxy` 的性能在某些情况下可能不如 `Object.defineProperty`，但它提供了更直接和灵活的方式来创建响应式数据，这在某些场景下可以提供更好的性能优化空间。

5. 可维护性：`Proxy` 的代码通常更简洁、更易于理解和维护，因为它不需要为每个属性单独设置拦截器。

总的来说，`Proxy` 提供了更强大、更灵活、更全面的拦截能力，使得它成为实现响应式系统和其他高级对象操作的首选方法。在 Vue 3 中，正是由于这些优点，Vue 的响应式系统从 `Object.defineProperty` 迁移到了基于 `Proxy` 的实现。
3.  Vue 3.0 在编译方面有哪些优化？
Vue 3.0 在编译方面进行了以下几个关键优化：

1. **静态树提升（Static Tree Hoisting）**：Vue 3.0 的编译器会检测模板中完全静态的子树，然后将它们提升为常量，这样在组件的多次渲染中就不需要重新创建这些静态节点。

2. **静态属性提升（Static Props Hoisting）**：对于那些不会改变的静态属性，编译器也会将它们提升，避免在每次渲染时重复创建这些属性。

3. **Patch标记（Patch Flags）**：Vue 3.0 引入了 Patch Flags，这是一种优化手段，编译器会在生成的渲染函数中为动态节点添加标记（flag），以指示节点的类型和可能的变化。这样在更新过程中，Vue 可以更快地确定哪些节点需要被比较和更新。

4. **块树（Block Tree）**：Vue 3.0 的编译器会将模板分割成多个块（block），每个块包含了一组静态节点和动态节点。这种结构使得更新过程中可以跳过整个静态块，从而提高更新性能。

5. **事件侦听器缓存**：Vue 3.0 会缓存那些不依赖组件状态的事件侦听器，避免不必要的重新渲染。

6. **预字符串化（Pre-stringification）**：对于那些在编译时就能确定的静态内容，Vue 3.0 的编译器会预先将其转换为字符串，减少运行时的工作量。

7. **更好的Tree-shaking**：Vue 3.0 的编译器生成的代码更加友好于Tree-shaking，这意味着最终的打包文件中不会包含未使用的组件或库代码，从而减小了最终的包体积。

这些编译优化使得 Vue 3.0 的性能得到了显著提升，同时也减小了应用的打包体积，提高了应用的加载速度和运行效率。


# 新增微信小程序

1. 体积过大如何分包
微信小程序支持分包加载，允许开发者将小程序分成一个主包和多个分包，从而减轻主包的大小，实现按需加载，提高小程序的启动速度。以下是实现分包的基本步骤：

1. **配置分包**：在小程序的项目配置文件 `app.json` 中，使用 `subpackages` 字段来配置分包路径和分包根目录。

```json
{
  "pages": [
    "pages/index/index",
    // ... 主包其他页面
  ],
  "subpackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat/cat",
        // ... 分包A其他页面
      ]
    },
    {
      "root": "packageB",
      "pages": [
        "pages/dog/dog",
        // ... 分包B其他页面
      ]
    }
    // ... 可以配置更多分包
  ]
}
```

2. **主包与分包**：主包包含小程序的启动页面和一些必要资源，分包则包含不需要立即加载的页面和资源。主包的体积不应超过2MB，分包的体积限制为每个分包不超过2MB，所有分包加起来总和不超过20MB。

3. **分包加载**：用户在使用小程序时，主包会首先被加载。当用户需要访问分包中的页面时，小程序会自动下载并加载该分包，无需手动操作。

4. **优化策略**：合理规划分包内容，将不常用的功能、页面或大体积的资源放入分包中。例如，将一些较少访问的功能页面放入同一个分包中，或者根据用户行为将相关功能分到同一个分包中。

5. **分包预加载**：微信小程序支持分包预加载，可以在 `app.json` 中使用 `preloadRule` 字段指定哪些页面会预加载哪些分包。

```json
{
  // ...
  "preloadRule": {
    "pages/index/index": {
      "network": "all",
      "packages": ["packageA"]
    }
  }
}
```

通过以上步骤，可以有效地减小主包体积，加快小程序的启动速度，并按需加载其他分包内容，优化用户体验。
2. 小程序js和javascript区别
小程序的 JavaScript 环境与传统的浏览器 JavaScript 环境有一些区别，主要体现在以下几个方面：

1. **全局对象不同**：
   - 在浏览器中，全局对象是 `window`，而在小程序中，全局对象是 `wx`（微信小程序）或其他平台特定的全局对象（如支付宝小程序的 `my`，百度小程序的 `swan` 等）。

2. **API 差异**：
   - 小程序提供了一套自己的 API，用于实现界面渲染、数据存储、网络请求等功能，这些 API 与浏览器提供的 Web API 不同。
   - 小程序的 API 设计更符合移动端开发的需求，例如，它们提供了丰富的移动端设备接口，如摄像头、蓝牙、联系人等。

3. **运行环境限制**：
   - 小程序的 JavaScript 代码运行在小程序的宿主环境中，而不是传统的浏览器环境。因此，一些浏览器特有的功能（如 `document`、`window` 对象）在小程序中不可用。
   - 小程序的宿主环境对代码的大小、API 调用等有一定的限制。

4. **组件化结构**：
   - 小程序采用组件化的开发方式，页面由多个组件构成，每个组件包含自己的模板、样式和逻辑，这与传统的 Web 开发中的 DOM 操作有所不同。

5. **生命周期管理**：
   - 小程序页面和组件有自己的生命周期函数，这些函数与浏览器环境中的页面生命周期不同，更适合移动端应用的使用场景。

6. **模块化支持**：
   - 小程序支持使用 CommonJS 规范进行模块化开发，而在浏览器中，现代 JavaScript 开发通常使用 ES6 模块（`import`/`export`）。

7. **安全性**：
   - 小程序的 JavaScript 代码是在微信（或其他平台）的小程序环境中运行的，这个环境相对封闭，平台会对小程序进行审核，以确保代码的安全性。

总的来说，小程序的 JavaScript 环境是为移动端应用定制的，它提供了一套适合移动端开发的 API，并且在全局对象、运行环境、组件化结构、生命周期