1.说说对前端监控的理解
前端监控是指在用户浏览器端对网站或Web应用的性能、功能和用户行为进行实时跟踪和分析的过程。它主要包括以下几个方面：

1. 性能监控：跟踪页面加载时间、响应时间、资源加载情况等，以确保用户体验良好。
2. 错误监控：捕获并记录前端代码运行时的错误，包括JavaScript错误、资源加载失败等。
3. 用户行为监控：分析用户如何与网站或应用交互，包括点击、滚动、页面访问路径等。
4. 业务监控：监控关键业务流程是否正常运行，如购物车、支付流程等。

通过前端监控，开发者可以快速定位问题，优化性能，提升用户体验，并做出数据驱动的决策。

2.埋点上报的原理
埋点上报的原理是在前端代码中嵌入特定的监控代码（即“埋点”），用于捕获用户行为或应用状态，并将这些信息发送到服务器进行记录和分析。具体过程如下：

1. **埋点设置**：开发者在用户交互或者关键业务逻辑的位置嵌入代码，用于捕捉事件或数据。这些代码可以是手动埋点，也可以是自动埋点。

2. **事件捕获**：当用户与应用交互时（如点击按钮、提交表单等），埋点代码会捕获这些事件，并收集相关信息（如事件类型、时间戳、用户信息、页面信息等）。

3. **数据封装**：捕获的信息会被封装成数据包，通常是一个包含有关事件和上下文信息的JSON对象。

4. **数据上报**：封装好的数据包通过HTTP请求（通常是GET或POST请求）发送到后端服务器。这个过程可以是实时的，也可以是按照一定策略（如定时批量上报、事件触发上报等）进行。

5. **数据处理**：服务器接收到数据后，会进行存储、处理和分析。这些数据可以用于生成报告，帮助开发者理解用户行为，监控应用性能，发现和解决问题等。

6. **性能优化**：为了不影响用户体验，埋点上报通常需要考虑性能优化，比如使用异步请求、避免阻塞用户操作、限制数据上报频率等。

埋点上报是前端监控的重要组成部分，通过它可以收集到丰富的用户行为数据和应用性能数据。

3.业务埋点和错误上报有何不同
业务埋点和错误上报是前端监控中的两个不同方面，它们的主要区别在于目的、内容和触发时机：

1. **业务埋点**：
   - **目的**：主要用于收集用户在应用中的行为数据，以及业务流程中的关键数据，用于分析用户行为、业务转化率、性能指标等。
   - **内容**：包括用户点击、页面访问、表单提交、交易完成等业务相关事件的信息，以及与这些事件相关的用户属性、会话信息等。
   - **触发时机**：通常在用户执行特定操作或达到特定业务流程节点时触发。

2. **错误上报**：
   - **目的**：用于捕获和记录前端应用运行时的错误，以便开发者及时发现并修复这些问题，提高应用的稳定性。
   - **内容**：包括JavaScript运行时错误、资源加载失败、接口请求异常等技术错误的详细信息，如错误消息、堆栈跟踪、发生错误的文件和行号等。
   - **触发时机**：当应用抛出异常或遇到错误时自动触发。

总结来说，业务埋点关注的是业务逻辑和用户行为，而错误上报关注的是应用的技术问题。两者都是前端监控的重要组成部分，但关注点和处理流程不同。

4.了解哪些首屏优化的方式
首屏优化是指提高网页首屏内容加载和渲染速度的一系列措施，以改善用户体验。以下是一些常见的首屏优化方法：

1. **代码分割**：使用工具如Webpack进行模块打包时，通过代码分割（Code Splitting）将代码拆分成多个小包，仅加载首屏需要的资源。

2. **懒加载**：延迟加载非首屏内容，如图片、视频等媒体资源，直到用户滚动到它们的位置时再加载。

3. **预加载**：对于即将需要的资源使用`<link rel="preload">`进行预加载，以减少加载时间。

4. **服务器端渲染（SSR）**：在服务器端完成HTML的生成，直接发送渲染好的页面给客户端，减少客户端渲染时间。

5. **关键CSS提取**：将用于首屏展示的关键CSS内联在HTML中，避免外部样式表加载阻塞渲染。

6. **字体优化**：优化字体文件的加载，使用`font-display`属性控制字体的加载行为，或者将关键字体内联。

7. **优化JavaScript执行**：推迟非关键JavaScript的执行，使用`async`或`defer`属性加载脚本。

8. **缓存利用**：通过合理设置HTTP缓存策略，利用浏览器缓存减少重复资源的加载时间。

9. **减少HTTP请求**：合并小文件，如CSS和JavaScript文件，减少HTTP请求的数量。

10. **使用内容分发网络（CDN）**：通过CDN分发资源，减少资源的加载时间，尤其是对于地理位置分散的用户。

11. **图片优化**：压缩图片，使用更高效的图片格式（如WebP），并根据设备分辨率提供适当大小的图片。

12. **减少重绘和回流**：优化CSS和JavaScript，避免不必要的DOM操作，减少浏览器的重绘（repaint）和回流（reflow）。

13. **性能监控**：使用性能监控工具（如Lighthouse、WebPageTest）定期检测和分析性能瓶颈。

通过这些优化措施，可以显著提高首屏加载速度，从而改善用户的访问体验。


5.prefetch和preload的区别和使用场景
`<link rel="prefetch">` 和 `<link rel="preload">` 是两种浏览器资源提示，它们帮助开发者控制资源的加载时机，但它们的目的和使用场景有所不同。

**Preload（预加载）**：
- **目的**：告诉浏览器页面必定会用到的资源，浏览器应尽早加载这些资源，通常是当前页面即将需要的资源。
- **使用场景**：当你知道某个资源在当前页面即将被用到时，比如在页面解析的早期阶段就需要的字体文件、脚本或样式表。
- **语法示例**：
  ```html
  <link rel="preload" href="important-script.js" as="script">
  <link rel="preload" href="styles.css" as="style">
  <link rel="preload" href="font.woff2" as="font" type="font/woff2" crossorigin>
  ```
- **特点**：preload 的资源在浏览器的加载优先级中通常比较高，它可以与浏览器的解析过程并行加载。

**Prefetch（预取）**：
- **目的**：告诉浏览器可能在未来的导航中用到的资源，浏览器在空闲时加载这些资源，通常是下一个页面会用到的资源。
- **使用场景**：当你预测用户可能会访问某个页面，并希望在浏览器空闲时提前获取页面所需资源时，比如用户可能点击的下一个页面的脚本或样式表。
- **语法示例**：
  ```html
  <link rel="prefetch" href="next-page-script.js">
  <link rel="prefetch" href="next-page-styles.css">
  ```
- **特点**：prefetch 的资源加载优先级较低，不会影响当前页面的关键加载，通常在浏览器空闲时进行。

总结：
- 使用 `preload` 时，你是在告诉浏览器：“我需要这些资源，而且很快就会用到它们。”
- 使用 `prefetch` 时，你是在告诉浏览器：“我可能在未来某个时候需要这些资源，如果你有空，请提前获取它们。”

正确使用这两种提示可以显著提高应用的性能，通过减少加载时间来改善用户体验。

6.怎么优化包的体积
优化包体积是前端性能优化的重要方面，以下是一些常用的方法：

1. **代码分割（Code Splitting）**：将代码拆分成多个小包，只在需要时加载，特别是对于单页应用（SPA）。

2. **树摇（Tree Shaking）**：移除未使用的代码，通常在构建过程中由模块打包工具（如Webpack）完成。

3. **压缩（Minification）**：通过工具（如Terser）压缩JavaScript代码，移除空格、注释、重命名变量以减少体积。

4. **优化CSS**：使用PurgeCSS等工具移除未使用的CSS，压缩和合并CSS文件。

5. **使用更高效的库或框架**：评估并可能替换体积较大的库和框架。

6. **按需加载（Lazy Loading）**：延迟加载非关键资源，如图片、字体、代码模块等。

7. **移除重复代码（Deduplication）**：确保没有引入重复的库或模块。

8. **使用外部链接（Externals）**：将常用的库（如React、Vue）通过CDN引入，而不是打包到主文件中。

9. **优化图片和媒体文件**：压缩图片和视频，使用WebP等现代格式，实现响应式图片加载。

10. **使用动态导入（Dynamic Imports）**：使用import()语法按需动态导入模块。

11. **监控包大小**：使用Webpack Bundle Analyzer等工具监控包大小，识别体积大的模块。

12. **移除多余的polyfills**：只包含目标浏览器需要的polyfills。

13. **使用PWA（渐进式Web应用）技术**：缓存应用资源，减少重复加载。

14. **使用ES Modules**：利用ES Modules的静态结构特性来进行更有效的打包。

15. **限制包大小**：在构建过程中设置预算，以警告或错误形式阻止体积过大的包。

通过这些方法，可以有效减少包的体积，提高应用的加载速度和性能。
7.知道那些性能指标
性能指标是用来衡量网站或应用性能的关键数据点。以下是一些常见的性能指标：

1. **加载时间（Load Time）**：页面完全加载的总时间。
2. **首字节时间（Time to First Byte, TTFB）**：从用户发起请求到接收到第一个字节的时间。
3. **首次内容绘制（First Contentful Paint, FCP）**：页面的第一个文本或图像内容渲染的时间。
4. **首次有意义绘制（First Meaningful Paint, FMP）**：页面主要内容渲染的时间。
5. **最大内容绘制（Largest Contentful Paint, LCP）**：页面上最大文本块或图像元素渲染的时间。
6. **交互时间（Time to Interactive, TTI）**：页面完全可交互的时间。
7. **首次输入延迟（First Input Delay, FID）**：用户首次与页面交互（例如点击链接、按钮）到浏览器响应该交互的时间。
8. **累积布局偏移（Cumulative Layout Shift, CLS）**：页面加载过程中发生的意外布局偏移的总和。
9. **速度指数（Speed Index）**：页面内容填充的速度，反映视觉上页面内容加载的快慢。
10. **完全加载时间（Fully Loaded Time）**：页面上所有网络活动完成的时间点。
11. **阻塞时间（Blocking Time）**：在FCP和TTI之间，主线程被阻塞的总时间，无法响应用户输入。
12. **服务器响应时间（Server Response Time）**：服务器处理请求并返回响应所需的时间。

这些指标可以通过各种性能测试工具来测量，如Lighthouse、WebPageTest、PageSpeed Insights等。了解和监控这些性能指标对于优化用户体验和提高网站或应用的性能至关重要。

8.FP是什么
在性能指标中，"FP"可能代表 "Function Points"，即功能点数。功能点分析（Function Point Analysis, FPA）是一种衡量软件项目大小和复杂性的方法，它通过评估软件的功能和用户需求来量化软件的功能。功能点是衡量软件开发输出的一种单位，通常用于项目估算、成本分析和生产力评估。通过计算功能点，组织可以估计所需的开发工作量、时间和成本。


9.怎么计算FCP和FMP
FCP（First Contentful Paint）和FMP（First Meaningful Paint）是衡量网页加载性能的两个指标，它们都是用户体验的关键指标，用于描述页面内容呈现给用户的速度。

1. **FCP (First Contentful Paint)**:
   FCP指的是浏览器开始渲染页面上的第一个文本或图像内容的时间点。这个指标的计算通常由浏览器自动完成，并可以通过各种性能监测工具或API（如Performance API）来获取。FCP是一个时间点，通常以秒或毫秒为单位。

2. **FMP (First Meaningful Paint)**:
   FMP指的是页面主要内容开始出现在屏幕上的时间点，即用户认为页面已经基本可用的时刻。FMP的计算比FCP更复杂，因为它需要确定哪些内容对用户来说是“有意义的”。由于这种主观性，FMP的定义和计算方法可能因工具和平台而异。在某些情况下，FMP可能需要开发者手动标记页面上的关键元素，以帮助监测工具确定这一指标。

由于FMP的主观性和复杂性，Google的性能监测工具Lighthouse已经逐渐淘汰了FMP，转而使用更稳定的指标，如Largest Contentful Paint (LCP)，它衡量的是最大内容元素（如一张图片或文本块）渲染完成的时间。

要计算这些指标，你可以使用如下工具：
- Chrome DevTools的Performance面板
- Lighthouse
- WebPageTest
- PageSpeed Insights

这些工具会自动捕捉和计算FCP和其他相关性能指标，为你提供一个时间点，你可以据此评估和优化你的网页性能。


10.TTI怎么计算
TTI（Time to Interactive）是指网页从开始加载到主要子资源已加载并且能够快速、可靠地响应用户输入的时间。换句话说，TTI 是衡量网页可交互性的性能指标，它表示网页达到可用状态的时间点。

TTI 的计算通常由浏览器自动完成，并可以通过性能监测工具或 API（如 Performance API）来获取。计算 TTI 的过程涉及以下几个步骤：

1. **监测主要资源加载**：浏览器监测网页加载过程中的关键资源（如 HTML、CSS、JavaScript）。

2. **确定网页主线程空闲**：网页的主线程负责解析代码、执行脚本和更新渲染。TTI 要求主线程有足够的空闲时间来响应用户的交互，这通常意味着连续 5 秒内没有长任务（超过 50 毫秒的任务）。

3. **检查网页响应性**：网页必须能够响应用户的交互，如点击或滚动。

4. **记录时间点**：当上述条件满足时，记录下的时间点即为 TTI。

要获取 TTI 值，你可以使用以下工具：

- **Lighthouse**：这是一个由 Google 开发的开源工具，可以在 Chrome DevTools 中使用，也可以作为命令行工具或 Node 模块使用。Lighthouse 会自动计算 TTI 并在其性能报告中提供。

- **WebPageTest**：这是一个在线工具，可以测试网页的性能并提供详细的时间线和性能指标，包括 TTI。

- **Chrome DevTools**：在 Performance 面板中，你可以手动检查网页加载过程中的各个阶段，并估算 TTI。

TTI 是一个重要的性能指标，因为它直接关系到用户能够与网页互动的体验。一个低的 TTI 值通常意味着更好的用户体验。

11.强缓存和协商缓存的区别
强缓存和协商缓存是HTTP缓存机制的两种类型。

强缓存（HTTP Cache-Control 的 max-age 或 Expires）:
- 浏览器直接使用本地缓存，不与服务器进行通信。
- 控制强缓存的HTTP头主要有`Cache-Control`的`max-age`指令和`Expires`头。
- 当缓存有效时，资源加载非常快，因为不需要网络延迟。

协商缓存（HTTP ETag 或 Last-Modified）:
- 浏览器会向服务器发送请求，询问缓存资源是否更新。
- 控制协商缓存的HTTP头主要有`Last-Modified`/`If-Modified-Since`和`ETag`/`If-None-Match`。
- 如果服务器确认资源未更改（响应304 Not Modified），浏览器会使用本地缓存；如果资源已更改，服务器会发送新资源及200 OK状态码。
`max-age`和`Expires`用于控制强缓存，而`ETag`和`Last-Modified`用于控制协商缓存。它们的具体区别如下：

**max-age（Cache-Control的一部分）:**
- `max-age`是一个相对时间，表示资源在被认为过期之前可以被缓存多长时间（以秒为单位）。
- 它是HTTP/1.1中的Cache-Control头的一部分，优先级高于Expires头。
- 例如：`Cache-Control: max-age=3600`表示资源可以在本地缓存3600秒。

**Expires:**
- `Expires`是一个绝对时间，表示资源的过期时间和日期。
- 它是HTTP/1.0的头部，如果同时存在`max-age`和`Expires`，则`max-age`会覆盖`Expires`。
- 例如：`Expires: Wed, 21 Oct 2015 07:28:00 GMT`表示资源在指定的GMT时间后被认为是过期的。

**ETag（Entity Tag）:**
- `ETag`是资源的唯一标识符，通常是一个哈希值或版本号。
- 当浏览器拥有资源的缓存时，它会在随后的请求中发送`If-None-Match`头，其值为资源的ETag。
- 服务器会比较ETag，如果资源未更改，返回304 Not Modified状态码，否则返回新资源和200 OK状态码。

**Last-Modified:**
- `Last-Modified`是资源最后被修改的时间。
- 浏览器在拥有资源的缓存时，会在随后的请求中发送`If-Modified-Since`头，其值为资源的Last-Modified时间。
- 服务器会比较时间，如果资源自那时未被修改，返回304 Not Modified状态码，否则返回新资源和200 OK状态码。

总结：
- `max-age`和`Expires`用于指定资源何时过期，不需要请求服务器即可知道资源是否可用。
- `ETag`和`Last-Modified`用于服务器验证资源是否有更新，需要请求服务器来确定资源是否可以继续使用。
12.ETag的计算规则

ETag（Entity Tag）的计算规则不是由HTTP规范严格定义的，而是由服务器决定的。ETag的值通常是对资源的某种表示（如文件内容、最后修改时间等）进行哈希或其他形式的编码得到的一个唯一标识符。不同的服务器和应用可能采用不同的计算规则来生成ETag。以下是一些常见的ETag生成方法：

1. **文件内容哈希**：对文件内容应用哈希函数（如MD5、SHA-1等），生成一个哈希值作为ETag。这种方法可以确保内容的任何变化都会导致ETag的变化。

2. **文件最后修改时间**：将文件的最后修改时间（可能还包括文件大小）用作输入，生成ETag。这种方法较快，但可能不会捕捉到文件内容的微小变化。

3. **版本号或时间戳**：对于动态生成的内容，可能会使用版本号或生成内容时的时间戳来生成ETag。

4. **组合方法**：结合多种信息（如文件修改时间、文件大小、特定版本号等）来生成一个复合的ETag值。

服务器在生成ETag时，通常会确保同一资源的不同表示（例如，文件内容的不同版本）会产生不同的ETag值。这样，当资源更新时，ETag也会随之更新，使得客户端能够通过协商缓存机制来验证缓存的有效性。

需要注意的是，ETag的计算规则应该足够独特，以避免不同资源产生相同的ETag值（即碰撞）。同时，为了提高性能，ETag的生成过程应该尽量高效，以免成为服务器的性能瓶颈。

13.Babel的工作流程
Babel是一个广泛使用的JavaScript编译器，它允许开发者使用新的JavaScript语法（如ES6及以上版本）编写代码，然后将其转换为向后兼容的JavaScript版本（如ES5），以便在旧版浏览器或环境中运行。Babel的工作流程大致可以分为以下几个步骤：

1. **解析（Parsing）**:
   - 将源代码字符串解析成一个抽象语法树（AST）。这个过程通常分为两个阶段：词法分析（将代码字符串分解成token序列）和语法分析（将token序列转换成AST）。

2. **转换（Transformation）**:
   - 对AST进行遍历，并应用各种转换插件来修改或替换AST的节点。这些插件可以实现各种功能，比如将ES6语法转换为ES5，移除代码中的console.log语句，或者引入polyfills来模拟环境中不存在的API等。

3. **生成（Code Generation）**:
   - 将经过转换的AST再转换回JavaScript代码字符串。这个过程还可能包括代码的压缩和优化。

4. **输出（Output）**:
   - 输出转换后的代码，以及可能的source map（源代码映射，用于调试转换后的代码）。

Babel的工作流程是高度可配置的，开发者可以根据需要选择和配置插件，定义要使用的转换和polyfills。Babel的核心功能可以通过安装不同的插件和预设（presets）来扩展，预设是一组预定义的插件集合，如`@babel/preset-env`可以根据目标环境自动确定需要的插件和polyfills。


14.手写一个babel插件的流程
编写一个Babel插件通常涉及以下步骤：

1. **了解AST（抽象语法树）**:
   - 首先，你需要对AST有基本的了解。AST是源代码的树状结构表示，每个节点代表代码中的一部分（如表达式、语句等）。
   - 可以使用在线工具如AST Explorer来查看JavaScript代码的AST结构。

2. **确定插件目标**:
   - 明确你的插件需要做什么。例如，你可能想要转换某种特定的语法，或者注入额外的代码。

3. **设置插件结构**:
   - Babel插件是一个函数，该函数返回一个对象，对象中包含一个`visitor`属性。`visitor`对象定义了对AST的不同节点类型的访问方法。

4. **编写访问者方法**:
   - 在`visitor`对象中，为你想要处理的AST节点类型编写方法。这些方法接收节点作为参数，并可以对其进行修改。
   - 常用的访问者方法有`enter`（进入节点时调用）和`exit`（离开节点时调用）。

5. **使用Babel类型构造器**:
   - 使用Babel提供的类型构造器（`@babel/types`）来创建或更新节点。

6. **测试插件**:
   - 编写测试用例来确保你的插件按预期工作。

7. **发布插件**:
   - 如果你想与他人分享你的插件，可以将其发布到npm上。

以下是一个简单的Babel插件示例，该插件会将所有的变量声明从`var`转换为`let`：

```javascript
module.exports = function(babel) {
  const { types: t } = babel;

  return {
    name: "convert-var-to-let", // 插件名称
    visitor: {
      VariableDeclaration(path) {
        if (path.node.kind === "var") {
          path.node.kind = "let";
        }
      }
    }
  };
};
```

在这个插件中，我们定义了一个访问者方法`VariableDeclaration`，它会检查变量声明的类型。如果声明类型为`var`，我们就将其更改为`let`。

要测试这个插件，你可以创建一个包含`var`声明的JavaScript文件，并使用Babel CLI或其他工具来运行你的插件，查看输出是否如预期将`var`转换为`let`。


15.了解哪些hooks
在React中，Hooks 是一种允许你在函数组件中使用 state 和其他 React 特性的机制。以下是一些常用的 React Hooks：

1. **useState**:
   - 用于在函数组件中添加状态。

2. **useEffect**:
   - 用于处理副作用，类似于类组件中的`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`生命周期方法。

3. **useContext**:
   - 用于访问 React 的 Context API，可以让你在组件树中传递数据而不必使用props。

4. **useReducer**:
   - 类似于`useState`，但适用于更复杂的状态逻辑，它接受一个reducer函数来管理状态。

5. **useCallback**:
   - 返回一个记忆化的回调函数，只有在依赖项改变时才会更新。

6. **useMemo**:
   - 返回一个记忆化的值，只有在依赖项改变时才会重新计算。

7. **useRef**:
   - 返回一个可变的ref对象，可以用来持久化保存数据，也常用于引用DOM元素。

8. **useLayoutEffect**:
   - 类似于`useEffect`，但它在所有DOM变更之后同步触发，可以用来读取DOM布局并同步触发重渲染。

9. **useImperativeHandle**:
   - 与`useRef`结合使用，可以在使用ref时自定义暴露给父组件的实例值。

10. **useDebugValue**:
    - 用于在React开发者工具中显示自定义的hook标签，方便调试。

这些是React官方提供的基础Hooks。此外，你还可以创建自定义Hooks来封装组件逻辑，使其在不同组件之间可重用。自定义Hooks通常是基于上述基础Hooks构建的。


16.useMemo和useCallBack的区别

`useMemo` 和 `useCallback` 都是 React Hooks，它们的共同点是都可以缓存计算结果或函数，以避免在每次组件渲染时都进行不必要的计算或生成新的函数实例。不过，它们的用途和应用场景有所不同：

**useMemo**:
- `useMemo` 用于缓存一个值的计算结果。
- 它接收一个“创建”函数和一个依赖项数组。只有当依赖项数组中的值发生变化时，才会重新计算这个值。
- 用途：当有复杂计算时，使用 `useMemo` 可以避免在每次渲染时都重新计算。

示例：
```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```

**useCallback**:
- `useCallback` 用于缓存一个函数实例。
- 它接收一个回调函数和一个依赖项数组。只有当依赖项数组中的值发生变化时，才会返回一个新的函数实例。
- 用途：当你将回调函数传递给子组件，且不希望因为父组件的渲染而导致子组件不必要的重渲染时，使用 `useCallback` 可以避免这种情况。

示例：
```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

总结：
- `useMemo` 用于记忆值的计算结果，以避免重复计算。
- `useCallback` 用于记忆函数实例，以避免重复创建函数实例导致的子组件不必要的渲染。

在实际使用中，应该根据需要缓存的是计算结果还是函数实例来选择使用 `useMemo` 或 `useCallback`。不过，需要注意的是，过度优化有时会适得其反，因为记忆化也有一定的开销，所以应该在确实需要时才使用这些 Hooks。


17.如何实现三栏布局
实现三栏布局（左中右三列布局）有多种方法，以下是一些常见的实现方式：

1. **使用浮动（Floats）**:
```css
.container {
  overflow: hidden;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
  float: left; /* 左侧栏浮动 */
}
.right {
  float: right; /* 右侧栏浮动 */
}
.center {
  margin: 0 200px; /* 中间栏的外边距等于侧栏宽度 */
}
```

2. **使用Flexbox**:
```css
.container {
  display: flex;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
}
.center {
  flex: 1; /* 中间栏占据剩余空间 */
}
```

3. **使用CSS Grid**:
```css
.container {
  display: grid;
  grid-template-columns: 200px auto 200px; /* 三列的宽度 */
}
.left {
  grid-column: 1;
}
.center {
  grid-column: 2;
}
.right {
  grid-column: 3;
}
```

4. **使用绝对定位（Absolute Positioning）**:
```css
.container {
  position: relative;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
  position: absolute;
  top: 0;
}
.left {
  left: 0;
}
.right {
  right: 0;
}
.center {
  margin: 0 200px; /* 中间栏的外边距等于侧栏宽度 */
}
```

5. **使用表格布局（Table Layout）**:
```css
.container {
  display: table;
  width: 100%;
}
.left, .center, .right {
  display: table-cell;
}
.left, .right {
  width: 200px; /* 侧栏宽度 */
}
.center {
  /* 中间栏自动填充剩余空间 */
}
```

在实际应用中，Flexbox 和 CSS Grid 是现代、灵活且强大的布局方法，它们提供了更好的响应式设计支持和更简洁的代码。而传统的浮动和绝对定位方法可能需要更多的样式规则和清除技巧来确保布局的正确性。根据项目的需求和浏览器兼容性选择合适的布局方法。

18.RN容器和浏览器容器的区别
RN容器通常指的是React Native应用中的环境，它允许JavaScript代码直接控制本地组件和设备API，用于构建原生移动应用。

浏览器容器则是指Web浏览器提供的环境，它允许HTML、CSS和JavaScript代码在浏览器中运行，用于构建和展示网页。

两者的主要区别在于它们的运行环境和目标平台：RN容器针对移动应用，直接与本地API交互；浏览器容器针对Web应用，运行在浏览器中。

19.动态化容器
动态化容器通常指的是能够动态加载和执行代码的环境，这种容器可以在运行时根据需要加载新的模块或组件，而不需要重新启动或重新部署整个应用。这种技术在多种场景中有应用，比如：

1. **Web应用动态加载**：浏览器可以动态加载JavaScript模块，实现按需加载功能，提高性能和用户体验。
2. **移动应用热更新**：React Native等框架支持热更新机制，可以在不发布新版本的情况下更新应用的部分代码。
3. **微服务架构**：在微服务架构中，容器（如Docker容器）可以动态地启动和停止，实现服务的弹性伸缩。

动态化容器的关键优势在于它们提供了更高的灵活性和效率，允许开发者快速响应变化，实现持续集成和持续部署（CI/CD）。


React Native等框架支持热更新（Hot Reloading）机制的实现原理主要基于以下几个步骤：

1. **代码打包**：开发者对JavaScript代码进行修改后，通过React Native的打包工具（如Metro Bundler）将修改后的代码打包成一个或多个更新文件（通常是一个bundle文件）。

2. **更新分发**：打包后的更新文件通过服务器分发给客户端。这通常通过OTA（Over-The-Air）更新服务实现，如CodePush等。

3. **下载更新**：React Native应用在客户端检测到新的更新后，会下载这些更新文件，并保存到设备的本地存储中。

4. **模块替换**：下载完成后，应用会使用新的JavaScript bundle替换掉当前正在使用的bundle。这个过程不需要重启应用。

5. **热重载**：React Native框架会触发一个热重载的过程，这通常涉及到新旧模块的对比，以及只更新改变了的模块，而不是整个应用。

6. **状态保持**：为了不影响用户体验，热更新机制会尽可能保持应用的当前状态，比如用户在表单中输入的数据，或者导航栈的状态。

需要注意的是，热更新通常只适用于JavaScript代码和资源文件的更新。对于原生代码（如iOS的Objective-C/Swift或Android的Java/Kotlin）的更改，还是需要通过应用商店进行标准的更新流程。此外，热更新需要遵守苹果App Store和谷歌Play Store的相关政策，某些类型的更新可能不允许通过热更新的方式进行。

Webpack的热模块替换（Hot Module Replacement，HMR）功能是通过一系列机制来实现的：

HMR Runtime：Webpack会在构建过程中生成用于热更新的运行时代码，这部分代码负责在客户端与服务器端之间建立WebSocket连接，用于传输更新的模块代码。

HMR 插件：在Webpack配置中，需要使用webpack.HotModuleReplacementPlugin插件来启用HMR功能。这个插件会负责在运行时处理模块的热替换逻辑。

客户端更新：当某个模块发生变化时，Webpack会通过WebSocket将更新的模块代码推送到客户端。客户端接收到更新后会根据新的模块代码进行局部更新，从而实现页面的实时更新。

模块标识：为了实现模块的热替换，Webpack会给每个模块分配一个唯一的标识符，用于在运行时进行模块的匹配和替换。

20.ESM和CJS的区别
ESM（ECMAScript Modules）和CJS（CommonJS）是JavaScript中两种不同的模块系统。它们的主要区别包括：

1. **语法**：
   - ESM使用`import`和`export`语句来导入和导出模块。
   - CJS使用`require()`函数来导入模块，并通过`module.exports`或`exports`对象来导出模块。

2. **加载机制**：
   - ESM是静态的，意味着`import`和`export`必须位于模块的顶层作用域，且不能动态地改变导入导出的内容。
   - CJS是动态的，可以在代码的任何地方调用`require()`，并且可以根据条件动态地导入模块。

3. **模块解析**：
   - ESM模块默认使用文件的完整路径或URL作为模块标识符。
   - CJS模块通常使用文件路径或者包名来解析模块。

4. **异步加载**：
   - ESM支持异步加载模块，可以与`import()`表达式一起使用来实现代码分割和懒加载。
   - CJS通常不支持异步加载，它是同步加载模块的。

5. **生态系统**：
   - ESM是ECMAScript标准的一部分，被现代浏览器和最新版本的Node.js支持。
   - CJS是Node.js特有的模块系统，广泛用于Node.js的应用程序和库中。

6. **交互兼容性**：
   - 在Node.js中，ESM和CJS模块可以互相导入，但是需要遵循特定的规则和限制。

随着JavaScript生态系统的发展，ESM正逐渐成为主流的模块系统，特别是在前端开发中，但CJS由于其在Node.js中的广泛使用，仍然非常重要。


21.HTTPS的加密过程
HTTPS（超文本传输安全协议）的加密过程涉及以下几个关键步骤：

1. **客户端发起连接**：浏览器（客户端）向服务器发起HTTPS请求，通常是通过在URL中使用`https://`前缀。

2. **服务器发送证书**：服务器响应客户端的请求，并发送其SSL/TLS证书。这个证书包含了服务器的公钥以及由证书颁发机构（CA）签名的证书信息。

3. **验证证书**：客户端验证服务器证书的有效性，确保它是由受信任的CA签发，且未过期、未被撤销。

4. **密钥交换**：
   - 客户端生成一个随机的对称加密密钥（会话密钥），用于本次会话的加密。
   - 客户端使用服务器的公钥加密这个会话密钥，然后发送给服务器。
   - 服务器使用自己的私钥解密这个消息，获取会话密钥。

5. **对称加密通信**：双方使用这个会话密钥对传输的数据进行对称加密。这意味着客户端和服务器都使用相同的密钥来加密和解密数据。

6. **安全数据传输**：客户端和服务器现在可以通过这个加密的通道安全地交换信息。所有传输的数据都使用会话密钥进行加密，任何中间人都无法解读这些加密的数据。

7. **会话结束**：一旦会话结束，双方都会丢弃用于该会话的对称密钥，以确保会话的安全性。

HTTPS通过结合非对称加密（用于密钥交换）和对称加密（用于数据传输）的方式，确保了数据传输的安全性和效率。非对称加密虽然安全但计算量大，适合加密小量数据（如密钥交换），而对称加密计算量小，适合加密大量数据。

22.HTTP/2的新特征
HTTP/2引入了多项新特性，旨在提高网络性能和效率。主要特性包括：

1. **二进制分帧**：HTTP/2使用二进制格式传输数据，而不是HTTP/1.x的文本格式。这种二进制分帧层允许更有效的解析和更少的错误，并减少了网络延迟。

2. **多路复用**：在同一个TCP连接上并行传输多个请求和响应，消除了HTTP/1.x中的队头阻塞问题，提高了连接的利用率。

3. **头部压缩**：HTTP/2使用HPACK压缩算法减少了头部大小，通过编码和传输常见的头部字段，减少了冗余头部信息的传输。

4. **服务器推送**：服务器可以在客户端请求之前发送资源，这可以加快页面加载时间，因为服务器可以预测客户端将需要的资源并主动发送它们。

5. **流控制**：HTTP/2提供了流控制机制，允许客户端和服务器对数据流的发送速率进行控制，以避免发送方快速发送数据导致接收方处理不过来。

6. **优先级**：客户端可以指定请求的优先级，使得服务器可以根据这些优先级处理请求，优先发送更重要的资源。

7. **增强的安全性**：虽然HTTP/2协议本身不要求加密，但在实践中，几乎所有的HTTP/2实现都是通过HTTPS来使用的，这意味着加密是HTTP/2的事实标准。

这些特性使得HTTP/2比HTTP/1.x更加高效，能够更好地利用网络资源，减少延迟，并提高页面加载速度。

23.HTTP/3
HTTP/3是HTTP协议的下一个主要版本，它引入了一些重要的新特性，主要包括：

1. **基于QUIC协议**：HTTP/3使用QUIC（Quick UDP Internet Connections）作为传输层协议，而不是TCP。QUIC基于UDP，旨在减少连接和传输延迟。

2. **连接建立的改进**：由于QUIC协议的使用，HTTP/3可以减少连接建立时的往返次数（RTT），在最佳情况下，新的QUIC连接只需要一个RTT就可以完成握手并开始数据传输。

3. **内置TLS加密**：QUIC协议内置了TLS 1.3加密，这意味着所有HTTP/3连接都是加密的，提高了安全性。

4. **改进的多路复用**：HTTP/3继续支持HTTP/2的多路复用特性，但由于QUIC协议的使用，HTTP/3避免了TCP连接中的队头阻塞问题，即使在丢包情况下也能保持多个独立的流的高效传输。

5. **连接迁移**：QUIC支持连接迁移，这意味着即使底层网络发生变化（例如，用户的移动设备从Wi-Fi切换到移动数据），连接也可以保持不中断。

6. **流优先级**：HTTP/3允许为不同的数据流设置优先级，使得重要资源可以被优先传输。

7. **前向纠错**：QUIC协议支持前向纠错（FEC），这可以在某些情况下减少因丢包导致的重传，进一步减少延迟。

8. **服务器推送**：HTTP/3继续支持HTTP/2中的服务器推送特性，允许服务器主动发送客户端可能需要的资源。

HTTP/3的这些新特性旨在提高Web性能，减少延迟，提供更可靠的连接，并改善移动设备的网络体验。由于HTTP/3基于UDP，它还需要解决UDP流量在某些网络中可能受到限制或阻塞的问题。

24.给定一个不含重复数字的数组nums。返回其所有可能得全排列，你可以按照任意顺序返回答案。
function permute(nums) {
  let result = [];
  let path = [];

  function backtrack(availableNums) {
    if (path.length === nums.length) {
      // 如果当前路径包含了所有数字，则将其添加到结果中
      result.push([...path]);
      return;
    }

    for (let i = 0; i < availableNums.length; i++) {
      // 选择当前数字
      path.push(availableNums[i]);
      // 将当前数字从可选列表中移除，并递归调用
      backtrack(availableNums.slice(0, i).concat(availableNums.slice(i + 1)));
      // 撤销选择
      path.pop();
    }
  }

  backtrack(nums);
  return result;
}

// 示例
console.log(permute([1, 2, 3]));


25.实现一个批量请求函数multiRequst(urls，maxNum),要求如下，1.要求最大并发数maxNum，2.每当一个请求返回，就留下一个空位，可以增加新的请求。
3.所有请求完成，结果按照urls里面的顺序一次打印


function multiRequest(urls, maxNum) {
  // 用于存储所有请求的Promise
  const allPromises = new Array(urls.length);
  // 当前正在执行的请求数量
  let running = 0;
  // 当前请求的索引
  let current = 0;

  return new Promise((resolve) => {
    // 定义请求函数
    function next() {
      // 所有请求都发起后，不再继续
      if (current >= urls.length) {
        // 检查是否所有请求都完成了
        if (running === 0) {
          resolve(Promise.all(allPromises));
        }
        return;
      }
      // 获取当前请求的URL
      const url = urls[current];
      // 记录当前请求的索引，以便在结果数组中保持顺序
      const index = current;
      // 发起请求，并将Promise存储在结果数组中
      const promise = fetch(url)
        .then((response) => response.text()) // 假设响应需要转换为文本
        .finally(() => {
          // 请求完成后，减少正在执行的请求数量
          running--;
          // 并发数有空位时，发起新的请求
          next();
        });
      allPromises[index] = promise;

      // 更新索引和正在执行的请求数量
      current++;
      running++;
      // 如果还有并发请求的空位，继续发起请求
      if (running < maxNum) {
        next();
      }
    }

    // 启动最初的并发请求
    for (let i = 0; i < maxNum; i++) {
      next();
    }
  });
}

// 示例使用
const urls = [
  'https://example.com/api/1',
  'https://example.com/api/2',
  // 更多URLs...
];
const maxNum = 3; // 最大并发数

multiRequest(urls, maxNum).then((results) => {
  console.log(results); // 按urls顺序打印结果
});
